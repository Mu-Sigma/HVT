---
title: "muHVT: Collection of functions used for vector quantization and construction of hierarchical voronoi tessellations for data analysis"
author: "Zubin Dowlaty, Shubhra Prakash, Sangeet Moy Das, Shantanu Vaidya, Praditi Shah, Somya Shambhawi "
date: "`r Sys.Date()`"
fig.height: 4
fig.width: 15
output:
  rmarkdown::html_vignette:
    number_sections: true
    toc: true
    toc_depth : 2
vignette: >
  %\VignetteIndexEntry{Collection of functions used for vector quantization and construction of hierarchical voronoi tessellations for data analysis"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{css, echo=FALSE}
/* CSS for floating TOC on the left side */
#TOC {
    /* float: left; */
    position: fixed;
    margin-left: -22vw;
    width: 18vw;
    height: fit-content;
    overflow-y: auto;
    padding-top: 20px;
    padding-bottom: 20px;
    background-color: #f9f9f9;
    border-right: 1px solid #ddd;
    margin-top: -18em;
}

.main-container {
  margin-left: 220px; /* Adjust this value to match the width of the TOC + some margin */
}

li {
  padding-bottom: 5px;
}
  
```

```{r setup, warning = FALSE, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "672px",
  out.height = "480px",
  fig.width = 7,
  fig.height = 5,
  fig.align = "center",
  fig.retina = 1,
  dpi = 150
)
```

# Abstract

The muHVT package is a collection of R functions to facilitate building [topology preserving maps](https://link.springer.com/chapter/10.1007/1-84628-118-0_7) for rich multivariate data. Tending towards a big data preponderance, a large number of rows. A collection of R functions for this typical workflow is organized below :

1. **Data Compression**: Vector quantization (VQ), HVQ (hierarchical vector quantization) using means or medians. The goal is to compress the rows of a long data frame by applying a compression objective. This compression reduces the dimensionality of the data while preserving important information.

2. **Data Projection**: Dimension projection of the compressed cells to 1D,2D and 3D with the Sammons Nonlinear Algorithm. This step creates topology preserving map coordinates into the desired output dimension. Additionally, [embedding](https://en.wikipedia.org/wiki/embedding) can be learned from the compressed data to further enhance the representation of the multivariate data. Embedding provide a lower-dimensional space where high-dimensional vectors, such as word vectors, can be translated, making it easier to perform machine learning tasks on large inputs.

3. **Tessellation**: Create cells required for object visualization using the Voronoi Tessellation method, package includes heatmap plots for hierarchical Voronoi tessellations (HVT). This step enables data insights, visualization, and interaction with the topology preserving map. Useful for semi-supervised tasks where incorporating the structure of the data is essential.

4. **Prediction**: Scoring new data sets and recording their assignment using the map objects from the above steps, in a sequence of maps if required, enabling more advanced analysis and modeling.

This package additionally provides functions for computing Sammonâ€™s projection and plotting the heat map of the variables on the tiles of the tessellations.



<!-- ### 1.1 Installation of muHVT 4.0.0 -->

<!-- ``` r -->
<!-- library(devtools) -->
<!-- devtools::install_github(repo = "Mu-Sigma/muHVT", ref = "dev") -->
<!-- ``` -->

# Vignettes

## muHVT 4.0.0 | What's New?

08th May, 2023

This package now additionally provides functionality to predict cells and layers based on a set of maps to monitor entities over time.

The creation of a predictive set of maps involves five steps -

1. **Compress:** Compress the dataset using a percentage compression rate and a quantization threshold using the HVT() function to generate map A
2. **Remove novelty cells:** Manually identify and remove the novelty cells from the dataset using the removeNovelty() function
3. **Compress the dataset with novelty:** compress the dataset with novelty records using n_cells, depth and a quantization threshold     using the HVT() function to generate map B
4. **Compress the dataset without novelty:** Again, compress the dataset without novelty(s) using n_cells, depth and a quantization threshold using the HVT() function to generate map C
5. **Predict based on a predictive set of maps:** Using the predictLayerHVT function

Let us try to understand the steps with the help of the diagram below -

```{r mlayer_flow,echo=FALSE,warning=FALSE,fig.show='hold',message=FALSE,out.width='90%',fig.height=8,fig.cap='Figure 1: Flow diagram for predicting based on a set of maps using predictLayerHVT()'}
knitr::include_graphics('./predictLayerHVT_function.png')
```

Initially, the raw data is passed, and a highly compressed map A is constructed using the __`HVT`__ function. The output of this function will be hierarchically arranged vector quantized data that is used to identify the novelty cells in the dataset using the number of data points within each cell and the z-scores for each cell.

The identified novelty cell(s) is then passed to the __`removeNovelty`__ function along with map A. This function removes the identified novelty cell(s) from the dataset and stores them separately. The final output of this function is a list of two items - a dataset with novelty records, and a subset of the dataset without novelty cell(s).

The __`plotCells`__ function plots the Voronoi tessellations for the compressed map (map A) and highlights the identified novelty cell(s) in red on the plot. The function requires the identified novelty cell(s) number and the compressed map (map A) as input in order to plot the tessellations map and highlight those novelty cells on it.

The dataset with novelty records gotten as an output from the __`removeNovelty`__ function is then passed as an argument to the __`HVT`__ function with other parameters such as n_cells, quant.error, depth, etc. to construct another map (map B).

The dataset without novelty gotten as an output from the __`removeNovelty`__ function is then passed as an argument to the __`HVT`__ function with other parameters such as n_cells, quant.error, depth, etc. to construct another map (map C).

Finally, all the constructed maps are passed to the __`predictLayerHVT`__ function along with the test dataset on which the function will predict/score for finding which map and what cell each test record gets assigned to.





__For more detailed information on the functions mentioned above and their usage within the muHVT package, you can refer to the available vignettes__


Following are the links to the vignettes for the muHVT package:


1. [**muHVT Vignette:**](https://htmlpreview.github.io/?https://github.com/Somya545/muHVT/blob/master/vignettes/muHVT_vignette3.html) Contains descriptions of the functions used for vector quantization and construction of hierarchical voronoi tessellations for data analysis

2. [**muHVT Model Diagnostics Vignette:**](https://htmlpreview.github.io/?https://github.com/Somya545/muHVT/blob/master/vignettes/muHVT_model_diagnostics_vignette.html) Contains descriptions of functions used to perform model diagnostics and validation for muHVT model

3. [**muHVT : Predicting Cells and Layers using predictLayerHVT to monitor entities over time**](https://htmlpreview.github.io/?https://github.com/Somya545/muHVT/blob/master/vignettes/Predicting_Cells_and_Layers_using_predictLayerHVT.html) Contains descriptions of the functions used for monitoring entities over time using a predictive set of HVT maps






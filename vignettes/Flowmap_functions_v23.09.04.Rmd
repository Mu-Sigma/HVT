---
title: "Flow Map - Functions"
author: "Pon Anu Reka"
subtitle: v.23.09.02 | 
  Built on `r format(Sys.Date(), "%B %d, %Y")`
output: 
  html_document:
    number_sections: true
    keep_md: false
    fig_width: 8
    fig_align: "center"
    code_folding: hide
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    toc_depth: 6
    max-width: 100%
    overflow: scroll
editor_options: 
  markdown: 
    wrap: 72
---

<style type="text/css">
.main-container{
  max-width:100vw !important;
}
.superbigimage{
      overflow-x:scroll;
      white-space: nowrap;
  }
</style>


```{r, warning=FALSE,message=FALSE,include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "672px",
  out.height = "480px",
  fig.width = 7,
  fig.height = 5,
  fig.align = "center",
  fig.retina = 1,
  dpi = 150
)

```

</br>


# Function to create Timeseries Plot
 
**Description - It serves as a tool for exploring and understanding temporal patterns and transitions in the data**

This state_transition_plot function is designed to visualize and analyze sequential data representing state transitions. It takes as input a dataset with state information over time and generates different types of plots based on user preferences. Users can choose to create a timeseries plot of state transitions or a timeseries with lines connecting the state transitions. Additionally, the function allows for data sampling to focus on specific time periods.

**Usage**

> state_transition_plot(df, sample_size = 0.2, line_plot = FALSE, cellid_column = "Cell.ID", time_column = "t")

**Arguments**

* @param **df** (dataframe) - A dataframe with prediction output and along with the dataset we used for predictHVT function
* @param **sample_size** (numeric) - Need to specify the sampling value which ranges between 0.1 to 1. The highest value 1, outputs a plot with the entire dataset. Sampling of data takes place from the last
* @param **line_plot** (logical) - If TRUE, the output will be a timeseries plot with a line connecting the states according to the sample_size otherwise, a timeseries plot but without a line based on the sample_size will be the output
* @param **cellid_column** (character) - Specify the column name of Cell ID from the dataframe you pass to this function
* @param **time_column** (character) - Specify the column name of Cell ID from the dataframe you pass to this function


</br>

```{r timeseries_plot, results='asis', warning=FALSE, message=FALSE}

state_transition_plot <- function(df, sample_size = NULL, line_plot = NULL, cellid_column, time_column) {
  
  # Rename column names for Time and Cell for consistency
  colnames(df)[colnames(df) == time_column] <- "Timestamp"
  colnames(df)[colnames(df) == cellid_column] <- "Cell.ID"
  
  # Set default values for sample_size and line_plot if they are NULL
  if (is.null(sample_size)) sample_size <- 0.2
  if (is.null(line_plot)) line_plot <- FALSE
  
  # Calculate the number of rows to sample and sample the data based on the specified sample_size
  sampling_percent <- round(sample_size * nrow(df))
  sampled_data <- df[(nrow(df) - sampling_percent + 1):nrow(df), ]
  
  # Group and count frequencies of cell IDs, then arrange by timestamp
  sampled_data <- sampled_data %>%
    group_by(Cell.ID) %>%
    mutate(Frequency = n()) %>%
    arrange(Timestamp)
  
  ### Sampled Plot - Create a heatmap plot for sampled data
  timeseries_plot <- sampled_data %>%
    plot_ly(x = ~Timestamp, y = ~Cell.ID, z = ~Frequency,
            type = "heatmap", hovertemplate = "Timestamp: %{x}<br> Cell.ID : %{y}<br>Frequency: %{z}") %>%
    colorbar(title = "Frequency") %>%
    layout(title = "Flow Map for Sampled Data",
           xaxis = list(title = "Timestamp"),
           yaxis = list(title = "Cell ID"))
  
  ### Plot on the whole dataset with lines
  # Prepare data for state transitions with timestamps and frequencies
  state_transitions <- sampled_data %>%
    select(Timestamp, Cell.ID, Frequency)
  
  # Add a column for the next state (next cell ID)
  state_transitions <- state_transitions %>%
    mutate(Next_State = lead(Cell.ID))
  
  # Create a lined plot with scatter points and lines connecting them
  lined_plot <- state_transitions %>%
    plot_ly(x = ~Timestamp, y = ~Cell.ID, z = ~Frequency,
            type = "heatmap", hovertemplate = "Timestamp: %{x}<br> Cell.ID : %{y}<br>Frequency: %{z}") %>%
    colorbar(title = "Transition Frequency") %>%
    layout(title = "Flow Map for Sampled Data",
           xaxis = list(title = "Timestamp"),
           yaxis = list(title = "Cell ID")) %>% 
    add_trace(xend = ~lead(Timestamp), yend = ~Next_State, type = "scatter", mode = "markers",
              line = list(color = "black", width = 1), marker = list(color = "black", size = 1))
  
  # Check the sample_size and line_plot parameters and return the appropriate plot
  if (sample_size <= 1) {
    if (line_plot == TRUE) {
      return(lined_plot)
    } else if (line_plot == FALSE) {
      return(timeseries_plot)
    } else {
      stop("Invalid line_plot parameter. Use TRUE or FALSE.")
    }
  } else {
    stop("Invalid sample_size parameter. Use values between 0.1 to 1.")
  }
  
}

```


# Function to create Transition Probability Tables


</br>
**Description - It is useful for analyzing and visualizing state transition patterns in a dataset**

The get_transition_probability_table function calculates transition probabilities for distinct states within a specified column of a dataframe (df). It computes the likelihood of transitioning from one state to another in sequential rows and presents the results as data frames in a list. Each data frame contains information about the next state (Tplus1_States), the frequency of this transition (Frequency), and the calculated transition probability (Probability). Additionally, the function displays these probability tables for each unique state and stores them in a global variable named trans_prob_df

**Usage**

> get_transition_probability_table(df, cellid_column = "Cell.ID", time_column = "t")

**Arguments**

* @param **df** (dataframe) - A dataframe with prediction output and along with the dataset we used for predictHVT function
* @param **cellid_column** (character) - Specify the column name of Cell ID from the dataframe you pass to this function
* @param **time_column** (character) - Specify the column name of Cell ID from the dataframe you pass to this function

</br>


```{r trans_prob, results='asis', warning=FALSE, message=FALSE}
get_transition_probability_table <- function(df, cellid_column, time_column) {
  # Rename columns for consistency
  colnames(df)[colnames(df) == time_column] <- "Timestamp"
  colnames(df)[colnames(df) == cellid_column] <- "Cell.ID"
  
  # Get a sorted list of unique Cell.ID values
  cell_id_list <- unique(df$Cell.ID) %>% sort()
  
  # Initialize an empty list to store probability results for each Cell.ID
  prob_results <- lapply(cell_id_list, function(state) {
    # Find row numbers where the Cell.ID matches the current state
    row_numbers <- which(df[[cellid_column]] == state) + 1
    
    # Get the values of the next state (T+1) for the matching rows
    tplus1_states <- df[row_numbers, cellid_column]
    
    # Create a frequency table of T+1 states
    prob_table <- table(tplus1_states)
    
    # Calculate the total count of T+1 states
    total_count <- sum(prob_table)
    
    # Calculate probabilities for each T+1 state
    probabilities <- as.vector(prob_table) / total_count
    
    # Create a dataframe to store T+1 states, frequencies, and probabilities
    result_df <- data.frame(
      Tplus1_States = names(prob_table),
      Frequency = as.vector(prob_table),
      Probability = round(probabilities, 4)
    )
    
    return(result_df)
  })
  
  # Set names for the probability results list based on Cell.ID values
  names(prob_results) <- cell_id_list
  
  # Print and store the probability results

  lapply(cell_id_list, function(cell_id_index) {
    cat("### Cell ID", cell_id_index, "\n\n")
    cat("Probability table for Cell ID", cell_id_index, ":\n\n")
    tab <- as.data.frame(prob_results[[cell_id_index]])
    print(htmltools::tagList(DT::datatable(tab, rownames = FALSE, width = '70%')))
    cat("\n\n")
  })
  
  trans_prob_df <<- prob_results
}
```

</br>

# Function to reconcile Transition Probability using MarkovChain


</br>
**Description - It is used to generate and visualize transition probability matrices for state data**

The reconcile_transition_probability function computes and visualizes transition probabilities for state data, it calculates transition probabilities between consecutive states in the input dataset, both with and without self-transitions. The function generates heatmap visualizations for these transition probabilities, providing insights into state transitions over time. It performs Markov Chain analysis on the data, producing transition matrices with and without self-transitions, along with corresponding heatmaps.

**Usage**

> reconcile_transition_probability(df, hmap_type = "All", cellid_column = "Cell.ID", time_column = "Timestamp")

**Arguments**

* @param **df** (dataframe) - A dataframe with prediction output and along with the dataset we used for predictHVT function
* @param **hmap_type** (character) - If set to without_self_state, reconciliation plots for manual and Markovchain for highest transition probability excluding the self-state is given as output, if set to with_self_state, reconciliation plots for manual and Markovchain for highest transition probability considering the self-state is given as output and if set to All, plots including and excluding self-state is given as output
* @param **cellid_column** (character) - Specify the column name of Cell ID from the dataframe you pass to this function
* @param **time_column** (character) - Specify the column name of Cell ID from the dataframe you pass to this function

</br>

```{r reconcile_mc, results='asis', warning=FALSE, message=FALSE}
reconcile_transition_probability <- function(df, hmap_type = NULL, cellid_column, time_column) {
  
  # Rename columns for consistency
  colnames(df)[colnames(df) == time_column] <- "Timestamp"
  colnames(df)[colnames(df) == cellid_column] <- "Cell.ID"
  
  # Set default value for hmap_type if it is NULL
  if (is.null(hmap_type)) hmap_type <- "with_self_state"
  
  # Heatmap 1: Transition probability with self-state
  raw_data <- df %>% select("Cell.ID", "Timestamp")
  transition_values <- table(raw_data$Cell.ID[-nrow(raw_data)], raw_data$Cell.ID[-1])
  mat <- unclass(transition_values)
  normalized_value <- mat / rowSums(mat)
  melted_matrix <- melt(normalized_value)
  a_df <- melted_matrix %>% as.data.frame()
  colnames(a_df) <- c("StateFrom", "StateTo", "Probabilty")
  a_df$StateTo <- as.factor(a_df$StateTo)
  a_df$StateFrom <- as.factor(a_df$StateFrom)
  
  hmap1 <- plot_ly(
    data = a_df,
    x = a_df$StateFrom,
    y = a_df$StateTo,
    z = a_df$Probabilty,
    type = "heatmap",
    colorscale = "colz",
    showlegend = TRUE,
    hovertemplate = "Cell t: %{x}<br>Cell t+1: %{y}<br>Probability: %{z}"
  ) %>%
    layout(
      title = "Transition Matrix (With Self-Transitions)",
      xaxis = list(title = "Cell.ID From"),
      yaxis = list(title = "Cell.ID To"),
      autosize = FALSE,
      width = 750,
      height = 600
    )
  
  # Heatmap 2: Transition probability without self-state
  raw_data1 <- df
  transition_values1 <- table(raw_data1$Cell.ID[-nrow(raw_data1)], raw_data1$Cell.ID[-1])
  mat1 <- unclass(transition_values1)
  normalized_value1 <- mat1 / rowSums(mat1)
  
  # Set probability to 0 for transitions to the same state
  for (i in 1:nrow(normalized_value1)) {
    normalized_value1[i, i] <- 0
  }
  
  # Normalize again after setting self-transitions to 0
  normalized_value1 <- normalized_value1 / rowSums(normalized_value1)
  
  melted_matrix1 <- melt(normalized_value1)
  a_df1 <- melted_matrix1 %>% as.data.frame()
  colnames(a_df1) <- c("StateFrom", "StateTo", "Probabilty")
  a_df1$StateTo <- as.factor(a_df1$StateTo)
  a_df1$StateFrom <- as.factor(a_df1$StateFrom)
  
  hmap2 <- plot_ly(
    data = a_df1,
    x = a_df1$StateFrom,
    y = a_df1$StateTo,
    z = a_df1$Probabilty,
    type = "heatmap",
    colorscale = "colz",
    showlegend = TRUE,
    hovertemplate = "Cell t: %{x}<br>Cell t+1: %{y}<br>Probability: %{z}"
  ) %>%
    layout(
      title = "Transition Matrix (Without Self-Transitions)",
      xaxis = list(title = "Cell ID From"),
      yaxis = list(title = "Cell ID To"),
      autosize = FALSE,
      width = 750,
      height = 600
    )
  
  # Heatmap 3: Markov Chain state transition Probability
  mc_data <- df$Cell.ID
  mc <- markovchainFit(data = mc_data)
  trans_matrix <- mc$estimate
  trans_plot <- as(trans_matrix, "matrix")
  
  melted_matrix_mc <- melt(trans_plot)
  a_df_mc <- melted_matrix_mc %>% as.data.frame()
  colnames(a_df_mc) <- c("State_From", "State_To", "Probability")
  heatmap_data <- a_df_mc
  
  hmap3 <- plot_ly(
    data = heatmap_data,
    x = ~State_From,
    y = ~State_To,
    z = ~Probability,
    type = "heatmap",
    colors = colorRampPalette(c("white", "blue"))(100),
    hovertemplate = "Cell t: %{x}<br>Cell t+1: %{y}<br>Probability: %{z}"
  ) %>%
    layout(
      title = "Markovchain Transition Matrix (With Self-Transitions)",
      xaxis = list(title = "Cell ID From"),
      yaxis = list(title = "Cell ID To"),
      autosize = FALSE,
      width = 750,
      height = 600
    )
  
  trans_matrix_no_self <- trans_plot
  diag(trans_matrix_no_self) <- 0  # Set self-transitions to 0
  
  # Create the heatmap data frame
  melted_matrix_mc1 <- melt(trans_matrix_no_self)
  a_df_mc1 <- melted_matrix_mc1 %>% as.data.frame()
  colnames(a_df_mc1) <- c("State_From", "State_To", "Probability")
  
  # Create the heatmap without self-state
  hmap4 <- plot_ly(
    data = a_df_mc1,
    x = ~State_From,
    y = ~State_To,
    z = ~Probability,
    type = "heatmap",
    colors = colorRampPalette(c("white", "blue"))(100),
    hovertemplate = "Cell t: %{x}<br>Cell t+1: %{y}<br>Probability: %{z}"
  ) %>%
    layout(
      title = "Markovchain Transition Matrix (Without Self-Transitions)",
      xaxis = list(title = "Cell ID From"),
      yaxis = list(title = "Cell ID To"),
      autosize = FALSE,
      width = 750,
      height = 600
    )
  
  # Determine which heatmaps to return based on the hmap_type parameter
  if (hmap_type == "without_self_state") {
    return(list(hmap2, hmap4))
  } else if (hmap_type == "with_self_state") {
    return(list(hmap1, hmap3))
  } else if (hmap_type == "All") {
    return(list(hmap1, hmap2, hmap3, hmap4))
  } else {
    stop("Invalid plot_type parameter. Use 'without_self_state', 'with_self_state', or 'both'.")
  }
}

```

# Function to create Flowmap Visualizations


</br>

**Description - It is designed for creating and visualizing flow maps based on input data**

The generate_flow_maps function in R extracts centroid coordinates and probability data from input. It generates two types of flow maps, one based on the second-highest probability and another on the highest probability, using arrows to represent state transitions. Additionally, it offers optional animations to visualize transitions over time, either sorted by timestamps or based on the next state. Users can customize the type of maps and animations they want to create for exploring state transitions in their data.

**Usage**

> generate_flow_maps(hvt_model_output, transition_probability_df, hvt_plot_output, df, animation = "All", flow_map = "All", animation_speed = 2, threshold = 0.6, cellid_column = "Cell.ID", time_column = "t")


**Arguments**

* @param **hvt_model_output** (list) - It is an output list in hierarchy from hvt model training. To get the centroid coordinates, we retrieve the second element, then within the second element, obtain the 1st element's `1`. And to get the Cell IDs, we retrieve the third element, then within the third element, obtain the Cell.ID from summary
* @param **transition_probability_df** (dataframe) - A list of dataframes which is the output from the get_transition_probability_table function
* @param **hvt_plot_output** (list) - Base plot for the flow maps
* @param **df** (dataframe) - A dataframe with prediction output and along with the dataset we used for predictHVT function
* @param **animation** (character) - If set to time_based, dot animation for state transition with sorted Timestamp is the output. If set to state_based, arrow animation based on highest state excluding self-state will be the output. If set to All, both the animation will be resulted
* @param **flow_map** (character) - If set to self_state, dot flowmap for next state based on highest transition probability will be the output. If set to without_self_state, arrow flowmap with arrow-size based on the distance between the two states pointing to next state based on highest transition probability excluding self-state probability will be the output. If set to probability, arrow flowmap with arrow-size based on their probability pointing to next state based on highest transition probability excluding self-state will be the output. If set to All, all three flowmaps will be resulted
* @param **animation_speed** (numeric) - Must be numeric value and a factor of 100
* @param **threshold** (numeric) - It ranges between 0.1 to 1. This numeric variable is used to control the categorization of probability values into "High Probability" and "Low Probability" for the flow map type "Probability"
* @param **cellid_column** (character) - Specify the column name of Cell ID from the dataframe you pass to this function
* @param **time_column** (character) - Specify the column name of Cell ID from the dataframe you pass to this function

</br>


```{r r flowmap, results='asis', warning=FALSE, message=FALSE}
generate_flow_maps <- function(hvt_model_output, transition_probability_df, hvt_plot_output, df, animation = NULL, flow_map = NULL, animation_speed = NULL, threshold = NULL, cellid_column, time_column) {

  # Set default values for animation, flow_map, animation_speed, and threshold if they are NULL
  if (is.null(animation))animation <- "state_based"
  if (is.null(flow_map))flow_map <- "without_self_state"
  if (is.null(animation_speed))animation_speed <- 2
  if (is.null(threshold))threshold <- 0.6
  
  # Rename columns for consistency
  colnames(df)[colnames(df) == time_column] <- "Timestamp"
  colnames(df)[colnames(df) == cellid_column] <- "Cell.ID"
  # Get the centroid coordinates
  hvt_res1 <- hvt_model_output[[2]][[1]]$`1`
  hvt_res2 <- hvt_model_output[[3]]$summary$Cell.ID
  
  # Prepare cellID_coordinates
  coordinates_value1 <- lapply(1:length(hvt_res1), function(x) {
    centroids1 <- hvt_res1[[x]]
    coordinates1 <- centroids1$pt
  })
  cellID_coordinates <- do.call(rbind.data.frame, coordinates_value1)
  colnames(cellID_coordinates) <- c("x", "y")
  cellID_coordinates$Cell.ID <- hvt_res2
  
  # Function to get highest state and probability excluding self-state
  get_second_highest <- function(df) {
    df$Tplus1_States <- as.integer(df$Tplus1_States)
    max_probability_row <- df[which.max(df$Probability), ]
    max_probability_state <- max_probability_row$Tplus1_States
    
    other_states <- df$Tplus1_States[df$Probability != max(df$Probability)]
    
    if (length(other_states) > 0) {
      sorted_states <- other_states[order(-df$Probability[df$Tplus1_States %in% other_states])]
      if (length(sorted_states) >= 1) {
        next_highest_state <- sorted_states[1]
        next_highest_probability <- df$Probability[df$Tplus1_States == next_highest_state]
      } else {
        next_highest_state <- NA
        next_highest_probability <- NA
      }
    } else {
      next_highest_state <- NA
      next_highest_probability <- NA
    }
    
    return(data.frame(Tplus1_States = next_highest_state, Probability = next_highest_probability))
  }
  
  # Apply the function to each data frame in 'transition_probability_df'
  second_highest_states_list <- lapply(transition_probability_df, get_second_highest)
  
  # Combine the results into a single data frame
  second_state_df <- do.call(rbind, second_highest_states_list)
  
  # Function to get the highest probability state and probability
  get_highest_probability <- function(df) {
    df$Tplus1_States <- as.integer(df$Tplus1_States)
    max_probability_row <- df[which.max(df$Probability), ]
    highest_probability_state <- max_probability_row$Tplus1_States
    highest_probability_probability <- max_probability_row$Probability
    
    return(data.frame(Tplus1_States = highest_probability_state, Probability = highest_probability_probability))
  }
  
  highest_probability_states_list <- lapply(transition_probability_df, get_highest_probability)
  
  # Combine the results into a single data frame
  first_state_df <- do.call(rbind, highest_probability_states_list)
  
  # Subset the arrow starting coordinates based on the order
  current_state_data <- arrange(cellID_coordinates, Cell.ID)
  colnames(current_state_data) <- c("x1", "y1", "Cell.ID")
  
  # Dataframe for second_highest state
  merged_df1 <- cbind(current_state_data, second_state_df)
  merged_df1 <- merged_df1 %>%
    left_join(select(merged_df1, Cell.ID, x1, y1), by = c("Tplus1_States" = "Cell.ID")) %>%
    mutate(x2 = x1.y, y2 = y1.y) %>%
    select(-x1.y, -y1.y)
  colnames(merged_df1) <- c("x1", "y1", "Cell.ID", "Tplus1_States", "Probability", "x2", "y2")
  
  # Dataframe for highest state
  merged_df2 <- cbind(current_state_data, first_state_df)
  merged_df2 <- merged_df2 %>%
    left_join(select(merged_df2, Cell.ID, x1, y1), by = c("Tplus1_States" = "Cell.ID")) %>%
    mutate(x2 = x1.y, y2 = y1.y) %>%
    select(-x1.y, -y1.y)
  colnames(merged_df2) <- c("x1", "y1", "Cell.ID", "Tplus1_States", "Probability", "x2", "y2")
  merged_df2$Probability <- round(merged_df2$Probability, digits = 3)

  # Non-self state PLOT
  merged_df1 <- merged_df1 %>%
    mutate(distance = round(sqrt((x2 - x1)^2 + (y2 - y1)^2), 0))

  next_state_arrow_plot <- ggplot() +
    geom_segment(data = merged_df1, mapping = aes(x = x1, y = y1, 
                                                  xend = x1 + (x2 - x1) * 0.09 * sqrt((x2 - x1)^2 + (y2 - y1)^2), 
                                                  yend = y1 + (y2 - y1) * 0.09 * sqrt((x2 - x1)^2 + (y2 - y1)^2), 
                                                  color = distance),
                 arrow = arrow(length = unit(0.2, "cm")), linewidth = 1) +
    geom_point(data = cellID_coordinates, aes(x = x, y = y), size = 1) +
    geom_text(data = cellID_coordinates, aes(x = x, y = y, label = Cell.ID), vjust = -1, size = 3) +
    scale_color_gradient(low = "blue", high = "blue", 
                         name = "Distance",
                         breaks = seq(0, max(merged_df1$distance), by = 1))  +
    labs(title = "Flow map: Distance based on Euclidean Distance") + 
    guides(color = guide_legend(title = "Euclidean\nDistance")) + theme_minimal()
  
  # Self-state Plot
    prob1 <- merged_df2$Probability
    cellID_coordinates$prob1 <- prob1
    
    min_prob <- min(merged_df2$Probability)
    custom_breaks <- quantile(merged_df2$Probability, probs = seq(0, 1, by = 0.3))
    custom_breaks[1] <- min_prob - 1e-6
    merged_df2$CircleSize <- as.numeric(cut(merged_df2$Probability, breaks = custom_breaks, labels = seq(1, length(custom_breaks) - 1)))
    merged_df2$CircleSize <- ifelse(is.na(merged_df2$CircleSize), 3, merged_df2$CircleSize)
    self_state_plot <- ggplot() + 
      geom_point(data = cellID_coordinates, aes(x = x, y = y, color = prob1), size = 1) +
      geom_circle(data = merged_df2, aes(x0 = x1, y0 = y1, r = 0.5 * merged_df2$CircleSize)) +
      geom_text(data = cellID_coordinates, aes(x = x, y = y, label = Cell.ID), vjust = -1, size = 3) +
      scale_color_gradient(low = "blue", high = "blue", 
                           name = "Probability",
                           breaks = seq(0, max(cellID_coordinates$prob1), by = 0.005)) + 
      guides(color = guide_legend(title = "Transition\nProbability", override.aes=list(shape = 21, size = c(2, 3, 4))), fill = guide_legend(title = "Probability")) + 
      theme_minimal()
  
  
  # Create a new column "threshold" based on the mean
  
  prob_with_no_selfstate <- function(df) {
    df$Tplus1_States <- as.integer(df$Tplus1_States)
    max_probability_row <- df[which.max(df$Probability), ]
    max_probability_state <- max_probability_row$Tplus1_States
    
    # Exclude the row with the highest probability
    df <- df[df$Tplus1_States != max_probability_state, ]
    
    if (nrow(df) > 0) {
      # Calculate the total count of the remaining probabilities
      total_count <- sum(df$Probability)
      
      # Calculate probabilities based on the remaining rows
      probabilities <- as.vector(df$Probability) / total_count
      
      # Find the state with the highest probability among the remaining rows
      next_highest_state <- df$Tplus1_States[which.max(probabilities)]
      next_highest_probability <- max(probabilities)
    } else {
      next_highest_state <- NA
      next_highest_probability <- NA
    }
    
    return(data.frame(Tplus1_States = next_highest_state, Probability = next_highest_probability))
  }
  
  probability_without_selfstate_list <- lapply(transition_probability_df, prob_with_no_selfstate)
  
  
  # Combine the results into a single data frame
  third_df <- do.call(rbind, probability_without_selfstate_list)
  # Dataframe for second_highest state
  merged_df3 <- cbind(current_state_data, third_df)
  merged_df3 <- merged_df3 %>%
    left_join(select(merged_df3, Cell.ID, x1, y1), by = c("Tplus1_States" = "Cell.ID")) %>%
    mutate(x2 = x1.y, y2 = y1.y) %>%
    select(-x1.y, -y1.y)
  colnames(merged_df3) <- c("x1", "y1", "Cell.ID", "Tplus1_States", "Probability", "x2", "y2")
  merged_df3 <- merged_df3 %>%
    mutate(threshold_label = ifelse(Probability > threshold, "High", "Low"))
  merged_df3$Probability <- round(merged_df3$Probability, digits = 1)

  arrow_flow_map <- ggplot() +
    geom_segment(data = merged_df3, mapping = aes(x = x1, y = y1, xend = x1 + (x2 - x1) * 0.8 * Probability * ifelse(threshold_label == "High Probability", 1.3, 0.9), yend = y1 + (y2 - y1) * 0.8 * Probability * ifelse(threshold_label == "High Probability", 1.3, 0.9), color = Probability),
                 arrow = arrow(length = unit(0.2, "cm")), size = 1, linewidth = 1 ) +
    geom_point(data = cellID_coordinates, aes(x = x, y = y), size = 1) +
    geom_text(data = cellID_coordinates, aes(x = x, y = y, label = Cell.ID), vjust = -1, size = 3)  +
    scale_color_gradient(low = "blue", high = "blue", 
                         name = "Probability",
                         breaks = seq(0, max(merged_df3$Probability), by = 0.2))  + 
    guides(color = guide_legend(title = "Transition\nProbability")) + theme_minimal()
  
  # Flow map Animation based on Timestamp
  df <- df %>%
    group_by(Cell.ID) %>%
    mutate(Frequency = with(rle(Cell.ID), rep(lengths, lengths)))
  state_data <<- df %>%
    group_by(grp = cumsum(c(TRUE, diff(Cell.ID) != 0))) %>%
    slice(n())
  
  anime_data <- merge(state_data, cellID_coordinates, by = "Cell.ID")
  anime_data <- anime_data %>% mutate(Timestamp = round(Timestamp, 3)) %>% arrange(Timestamp)
  dot_anim <- ggplot(anime_data, aes(x = x, y=y)) +
    geom_point(data = cellID_coordinates, aes(x = x, y = y), size = 1) +
    geom_text(data = cellID_coordinates, aes(x = x, y = y, label = Cell.ID), vjust = -1, size = 3) +
    geom_point(show.legend = FALSE, alpha = 0.7, color = "red", size = 5) +
    scale_color_manual() + theme_minimal() + 
    labs(x = "x-coordinates", y = "y-coordinates")
  
  dot_anim <- dot_anim + transition_time(Timestamp) +
    labs(title = "Animation showing state transition") +
    shadow_wake(wake_length = 0.03, alpha = FALSE)
  time_animation <- animate(dot_anim, fps = animation_speed, duration = 2)
  # time_animation <- animate(dot_anim, fps = animation_speed, duration = 100)
  # anim_save("./source/time_animation.gif", animation = time_animation, width = 800, height = 400)
  
  ### Animation based on next state
  
  order <- unique(state_data$Cell.ID)
  anime_df <- merged_df1[order, ]
  anime_df$order_map <- 1:nrow(anime_df)
  anime_df$label <- rep("State\nTransition", nrow(anime_df))

  arrow_anim <- ggplot(anime_df, aes(x = x1, y = y1)) +
    geom_segment(data = anime_df, mapping = aes(x = x1, y = y1, xend = x1 + (x2 - x1) * 0.5, yend = y1 + (y2 - y1) * 0.5, color = label),
                 arrow = arrow(length = unit(0.2, "cm")), linewidth = 1) +
    geom_point(data = cellID_coordinates, aes(x = x, y = y), size = 1) +
    geom_text(data = cellID_coordinates, aes(x = x, y = y, label = Cell.ID), vjust = -1, size = 3) +
    scale_color_manual(values = c("State\nTransition" = "blue")) + 
    labs(x = "x-coordinates", y = "y-coordinates", color = "Transition\nProbability") + theme_minimal()
  
  
  animation1 <- arrow_anim + transition_states(order_map, wrap = FALSE) + shadow_mark() +
    labs(title = "Animation showing state transition excluding self-state")
  
  state_animation <- animate(animation1, fps = animation_speed, duration = 2)
  # state_animation <- animate(animation1, fps = animation_speed)
  # anim_save("./source/next_state_animation.gif", animation = state_animation, width = 800, height = 400)
  
  plots <- list()
  
  if (flow_map == "without_self_state" || flow_map == "All") {
    plots$without_self_state <- next_state_arrow_plot
  }
  
  if (flow_map == "self_state" || flow_map == "All") {
    plots$self_state <- self_state_plot
  }
  
  if (flow_map == "probability"|| flow_map == "All") {
    plots$flow_map <- arrow_flow_map
  }
  
  if (animation == "time_based" || animation == "All") {
    plots$time_based <- time_animation
  }
  
  if (animation == "state_based" || animation == "All") {
    plots$state_based <- state_animation
  }
  
  return(plots)
  
}
```

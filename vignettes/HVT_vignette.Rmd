---
title: "HVT: An Introduction"
author: "Zubin Dowlaty, Shubhra Prakash, Sangeet Moy Das, Praditi Shah, Shantanu Vaidya, Somya Shambhawi, Vishwavani"
date: "`r Sys.Date()`"
fig.height: 4
fig.width: 15
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth : 3
vignette: >
  %\VignetteIndexEntry{HVT: An Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{css, echo=FALSE}
/* CSS for floating TOC on the left side */
#TOC {
    /* float: left; */
    position: fixed;
    margin-left: -22vw;
    width: 18vw;
    height: fit-content;
    overflow-y: auto;
    padding-top: 20px;
    padding-bottom: 20px;
    background-color: #f9f9f9;
    border-right: 1px solid #ddd;
    margin-top: -10em; 
}
.main-container {
  margin-left: 222px; /* Adjust this value to match the width of the TOC + some margin */
}
body{
max-width:1200px;
width: 50%;
}
p {
text-align: justify;
}
.plotly {
  margin: auto;
  width: 100% !important; 
  height: 50vh !important;
}
.caption {
  text-align: center;
}
li {
  padding-bottom: 5px;
}
ul {
  margin-bottom: 0px !important;
}
```


```{r setup, warning = FALSE, include = FALSE}
# knitr::opts_chunk$set(
#   collapse = TRUE,
#   comment = "#>",
#   out.width = "auto",
#   out.height = "480px",
#   fig.width = 7,
#   fig.height = 5,
#   fig.align = "center",
#   fig.retina = 1,
#   dpi = 150)

list.of.packages <- c("dplyr", "kableExtra", "geozoo", "plotly", "purrr", "sp",  "data.table", "gridExtra","plyr")
new.packages <-
  list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
if (length(new.packages))
  install.packages(new.packages, dependencies = TRUE, repos='https://cloud.r-project.org/')
lapply(list.of.packages, library, character.only = TRUE)

options(expressions = 10000)
global_var <- nzchar(Sys.getenv("RUN_VIGNETTE"))
global_var <- TRUE
scrolLimit <- function(noOfRows){
  if(noOfRows<10){
    swe = paste(as.character(noOfRows*50),"px")
  }
  else{
    swe = "400px"
  }
  return(swe)
}

Table <- function(data,scroll = FALSE, limit = NULL){
  if(!is.null(limit)){
    data <- head(data,limit)
  }
  kable_table <- data %>% kable(escape = FALSE,align = "c") %>% kable_styling(bootstrap_options = c("striped", "hover", "responsive"))
  scroll <- scroll
  if(scroll == TRUE){
  kable_table <- kable_table %>% scroll_box(width = "100%", height = scrolLimit(nrow(data)))
  }
 return(kable_table)
}

set.seed(240)
```

# 1. Background

The HVT package is a collection of R functions to facilitate building <a href="https://link.springer.com/chapter/10.1007/1-84628-118-0_7" target="_blank">topology preserving maps </a> for rich multivariate data analysis. Tending towards a big data preponderance, a large number of rows. A collection of R functions for this typical workflow is organized below:

1.  **Data Compression**: Vector Quantization (VQ), HVQ (Hierarchical Vector Quantization) using means or medians. This step compresses the rows (long data frame) using a compression objective.

2.  **Data Projection**: Dimension projection of the compressed cells to 1D, 2D and Interactive surface plot with the Sammons Non-linear Algorithm. This step creates a topology preserving map (also called <a href="https://en.wikipedia.org/wiki/Embedding" target="_blank"> mathematical embeddings</a>) coordinates into the desired output dimension.

3.  **Tessellation**: Create cells required for object visualization using the Voronoi Tessellation method, package includes heatmap plots for Hierarchical Voronoi Tessellations (HVT). This step enables data insights, visualization, and interaction with the topology preserving map. Useful for semi-supervised tasks.

4.  **Scoring**: Scoring data sets and recording their assignment using the map objects from the above steps, in a sequence of maps if required.

5. **Temporal Analysis and Visualization**: A Collection of functions that leverages the capacity of the HVT package by analyzing time series data for its underlying patterns, calculation of transitioning probabilities and the visualizations for the flow of data over time.

# 2. Data Compression

Compression is a technique used to reduce the data size while preserving its essential information, allowing for efficient storage and decompression to reconstruct the original data. While Vector quantization (VQ) is a technique used in data compression to represent a set of data points with a smaller number of representative vectors. It achieves compression by exploiting redundancies or patterns in the data and replacing similar data points with representative vectors.


This package offers several advantages for performing data compression as it is designed to handle `high-dimensional data` more efficiently. It provides a `hierarchical compression approach`, allowing  multi-resolution representation of the data. The hierarchical structure enables `efficient compression` and `storage` of the data while preserving different levels of detail. HVT aims to preserve the topological structure of the data during compression. `Spatial data` with `irregular shapes` and complex structures in high-dimensional data can contain valuable information about relationships and patterns. HVT seeks to capture and retain these topological characteristics, enabling meaningful analysis and visualization.This package employs tessellation to divide the compressed data space into distinct cells or regions while preserving the topology of the original data. This means that the relationships and connectivity between data points are maintained in the compressed representation.


This package can perform vector quantization using the following algorithms- 

*  Hierarchical Vector Quantization using $k-means$ 
*  Hierarchical Vector Quantization using $k-medoids$


## 2.1 Hierarchical Vector Quantization

###  2.1.1 Using k-means

1. The k-means algorithm randomly selects *k* data points as initial means.
1. *k* clusters are formed by assigning each data point to its closest cluster mean using the Euclidean distance.
1. Virtual means for each cluster are calculated by using all datapoints contained in a cluster.

The second and third steps are iterated until a predefined number of iterations is reached or the clusters converge. The runtime for the algorithm is O(n).

###  2.1.2 Using k-medoids

1.  The k-medoids algorithm randomly selects *k* data points as initial
    means out of the n data points as the medoids.
2.  *k* clusters are formed by assigning each data point to its closest
    medoid by using any common distance metric methods.
3.  Virtual means for each cluster are calculated by using all
    datapoints contained in a cluster.

The second and third steps are iterated until a predefined number of
iterations is reached or the clusters converge. The runtime for the
algorithm is O(k \* (n-k)\^2).


These algorithm divides the dataset recursively into cells using $k-means$
or $k-medoids$ algorithm. The maximum number of subsets are decided by
setting $n_cells$ to, say five, in order to divide the dataset into
maximum of five subsets. These five subsets are further divided into
five subsets(or less), resulting in a total of twenty five (5\*5)
subsets. The recursion terminates when the cells either contain less
than three data point or a stop criterion is reached. In this case, the
stop criterion is set to when the cell error exceeds the quantization
threshold.

The steps for this method are as follows:

1. Select k(number of cells), depth and quantization error threshold.
1. Perform quantization (using $k-means$ or $k-medoids$) on the input dataset.
1. Calculate quantization error for each of the k cells.
1. Compare the quantization error for each cell to quantization error threshold.
1. Repeat steps 2 to 4 for each of the k cells whose quantization error is above threshold until stop criterion is reached.

The stop criterion is when the quantization error of a cell  satisfies one of the below conditions: 

* reaches below quantization error threshold.
* there are less than three data points in the cell.
* the user specified depth has been attained.

The quantization error for a cell is defined as follows:

$$QE  = \max_i(||A-F_i||_{p})$$ 


where 

*  $A$ is the centroid of the cell
*  $F_i$ represents a data point in the cell 
*  $m$ is the number of points in the cell
*  $p$ is the $p$-norm metric. Here $p$ = 1 represents L1 Norm and $p$ = 2 represents L2 Norm

###  2.1.3 Quantization Error

Let us try to understand quantization error with an example.

```{r Quantization Error,echo=FALSE,warning=FALSE,fig.show='hold',message=FALSE,fig.cap='Figure 1: The Voronoi tessellation for level 1 shown for the 5 cells with the points overlayed',  fig.width = 7, fig.height = 5}
knitr::include_graphics('./pngs/quant_explainer.png')
```

An example of a 2 dimensional VQ is shown above.

In the above image, we can see 5 cells with each cell containing a certain number of points. The centroid for each cell is shown in blue. These centroids are also known as codewords since they represent all the points in that cell. The set of all codewords is called a codebook.

Now we want to calculate quantization error for each cell. For the sake of simplicity, let's consider only one cell having centroid `A` and `m` data points $F_i$ for calculating quantization error.

For each point, we calculate the distance between the point and the centroid.

$$ d = ||A - F_i||_{p} $$

In the above equation, p = 1 means `L1_Norm` distance whereas p = 2 means `L2_Norm` distance. In the package, the `L1_Norm` distance is chosen by default. The user can pass either `L1_Norm`, `L2_Norm` or a custom function to calculate the distance between two points in n dimensions.

$$QE  = \max_i(||A-F_i||_{p})$$ 


Now, we take the maximum calculated distance of all m points. This gives us the furthest distance of a point in the cell from the centroid, which we refer to as `Quantization Error`. If the Quantization Error is higher than the given threshold, the centroid/ codevector is not a good representation for the points in the cell. Now we can perform further Vector Quantization on these points and repeat the above steps.

Please note that the user can select mean, max or any custom function to calculate the Quantization Error. The custom function takes a vector of m value (where each value is a distance between point in `n` dimensions and centroids) and returns a single value which is the Quantization Error for the cell.

If we select `mean` as the error metric, the above Quantization Error equation will look like this:  

$$QE  = \frac{1}{m}\sum_{i=1}^m||A-F_i||_{p}$$ 

# 3. Data Projection

Projection mainly involves converting data from its original form to a different space or coordinate system while preserving certain properties of it. By projecting data into a common coordinate system, spatial relationships, distances, areas, and other spatial attributes can be accurately measured and compared.

HVT performs projection as part of its workflow to visualize and explore high-dimensional data. The projection step in HVT involves mapping the compressed data, represented by the hierarchical structure of cells, onto a lower-dimensional space for visualization purposes, as human perception is more suited to interpreting information in lower-dimensional spaces.Users can zoom in/out, rotate, and explore different regions of the projected space to gain insights and understand the data from different perspectives.


Sammon's projection is an algorithm used in this package to map a high-dimensional space to a space of lower dimensionality while attempting to preserve the structure of inter-point distances in the projection. It is particularly suited for use in exploratory data analysis and is usually considered a non-linear approach since the mapping cannot be represented as a linear combination of the original variables. The centroids are plotted in 2D after performing Sammon’s projection at every level of the tessellation.


Denoting the distance between $i^{th}$ and $j^{th}$ objects in the original space by $d_{ij}^*$, and the distance between their projections by $d_{ij}$. Sammon’s mapping aims to minimize the below error function, which is often referred to as Sammon’s stress or Sammon’s error.

$$E=\frac{1}{\sum_{i<j} d_{ij}^*}\sum_{i<j}\frac{(d_{ij}^*-d_{ij})^2}{d_{ij}^*}$$

The minimization  of this can be performed either by gradient descent, as proposed initially, or by other means, usually involving iterative methods. The number of iterations need to be experimentally determined and convergent solutions are not always guaranteed. Many implementations prefer to use the first Principal Components as a starting configuration.

# 4. Tessellation

A Voronoi diagram is a way of dividing space into a number of regions. A set of points (called seeds, sites, or generators) is specified beforehand and for each seed, there will be a corresponding region consisting of all points within proximity of that seed. These regions are called `Voronoi cells`. It is complementary to `Delaunay triangulation` is a geometrical algorithm used to create a triangulated mesh from a set of points in a plane which has the property that no data point lies within the circumcircle of any triangle in the triangulation. This property guarantees that the resulting cells in the tessellation do not overlap with each other. 

By using `Delaunay triangulation`, HVT can achieve a partitioning of the data space into distinct and non-overlapping regions, which is crucial for accurately representing and analyzing the compressed data.Additionally, the use of Delaunay triangulation for tessellation ensures that the resulting cells have well-defined shapes, typically triangles in two dimensions or tetrahedra in three dimensions. 

The hierarchical structure resulting from tessellation preserves the inherent structure and relationships within the data. It captures clusters, subclusters, and other patterns in the data, allowing for a more organized and interpretable representation.
The hierarchical structure reduces redundancy and enables more compact representations.

**Tessellate: Constructing Voronoi Tesselation**

In this package, we use `sammons` from the package `MASS` to project higher dimensional data to a 2D space. The function `hvq` called from the `trainHVT` function returns hierarchical quantized data which will be the input for construction of the tessellations. The data is then represented in 2D coordinates and the tessellations are plotted using these coordinates as centroids. We use the package `deldir` for this purpose. The `deldir` package computes the Delaunay triangulation (and hence the Dirichlet or Voronoi tessellation) of a planar point set according to the second (iterative) algorithm of Lee and Schacter. For subsequent levels, transformation is performed on the 2D coordinates to get all the points within its parent tile. Tessellations are plotted using these transformed points as centroids. The lines in the tessellations are chopped in places so that they do not protrude outside the parent polygon. This is done for all the subsequent levels.

# 5. Scoring

Scoring basically refers to the process of chalking up or estimating future values or outcomes based on existing data patterns.In training process, a model is developed based on historical data or a training dataset, and this model is then used to score new, unseen data. The model captures the underlying patterns, trends, and relationships present in the training data, allowing it to pin point the cell of the similar or related data points.

In this package, we use `scoreHVT` function to score each point in the testing dataset.

**Scoring Algorithm**

The Scoring algorithm recursively calculates the distance between each point in the testing dataset and the cell centroids for each level. The following steps explain the scoring method for a single point in the testing dataset:

1. Calculate the distance between the point and the centroid of all the cells in the first level.
2. Find the cell whose centroid has minimum distance to the point.
3. Check if the cell drills down further to form more cells.
4. If it doesn’t, return the path. Or else repeat steps 1 to 4 till we reach a level at which the cell doesn’t drill down further.

# 6. Importing Code Modules

Here is the guide to install the HVT package. This helps user to install the most recent version of the HVT package.
```{r}
###direct installation###
#install.packages("HVT")

#or

###git repo installation###
#library(devtools)
#devtools::install_github(repo = "Mu-Sigma/HVT")

```


**NOTE:** At the time documenting this vignette, the updated changes were not still in CRAN, hence we are sourcing the scripts from the R folder directly to the session environment.
```{r, loading all the script files of the package, message=FALSE, warning=FALSE, include = TRUE}
# Sourcing required code scripts for HVT
script_dir <- "../R"
r_files <- list.files(script_dir, pattern = "\\.R$", full.names = TRUE)
invisible(lapply(r_files, function(file) { source(file, echo = FALSE); }))
```



# 7. Example I: HVT with the Torus dataset

**In this section we explore the capacity of the package to visualize multidimensional data by projecting them to two dimensions using Sammon's projection and further used for Scoring.**

**Data Understanding**

First of all, let us see how to generate data for torus. We are using a library `geozoo` for this purpose. Geo Zoo (stands for Geometric Zoo) is a compilation of geometric objects ranging from three to ten dimensions. Geo Zoo contains regular or well-known objects, eg cube and sphere, and some abstract objects, e.g. Boy's surface, Torus and Hyper-Torus. 

Here, we will generate a 3D torus (a torus is a surface of revolution generated by revolving a circle in three-dimensional space one full revolution about an axis that is coplanar with the circle) with 12000 points.

**Torus Dataset**

The torus dataset includes the following columns:

* x: This column represents the X-coordinate of each point in the torus.
* y: This column represents the Y-coordinate of each point in the torus.
* z: This column represents the Z-coordinate of each point in the torus.

Lets, explore the **torus dataset containing 12000 points**. For the sake of brevity we are displaying first 6 rows.

```{r torus generate,warning=FALSE,message=FALSE,eval = global_var}
set.seed(240)
# Here p represents dimension of object, n represents number of points
torus <- geozoo::torus(p = 3,n = 12000) 
torus_df <- data.frame(torus$points)
colnames(torus_df) <- c("x","y","z")
torus_df <- torus_df %>% round(4)
Table(head(torus_df))
```
Let's  visualize the torus (donut) in  3D Space.

```{r torus plot,warning=FALSE,message=FALSE,fig.show="hold",fig.cap='Figure 2: 3D Torus',eval =TRUE,echo=TRUE, fig.align='center'}
plot_ly(x = torus_df$x, y = torus_df$y, z = torus_df$z, type = 'scatter3d',mode = 'markers',
marker = list(color = torus_df$z,colorscale = c('red', 'blue'),showscale = TRUE,size = 3,colorbar = list(title = 'z'))) %>%
layout(scene = list(xaxis = list(title = 'x'),yaxis = list(title = 'y'),zaxis = list(title = 'z'),
aspectratio = list(x = 1, y = 1, z = 0.4)))
 
```
Now let's have a look at **structure** of the torus dataset.

```{r, message=FALSE, warning=FALSE}
str(torus_df)
```

**Data distribution**

This section displays four objects.

**Variable Histograms**: The histogram distribution of all the features in the dataset.

**Box Plots**: Box plots for all the features in the dataset. These plots will display the median and Interquartile range of each column at a panel level.

**Correlation Matrix**: This calculates the Pearson correlation which is a bivariate correlation value measuring the linear correlation between two numeric columns. The output plot is shown as a matrix.

**Summary EDA**: The table provides descriptive statistics for all the features in the dataset.

- *variable*: The features/columns of the dataset
- *min*: Minimum value of that feature/column
- *1st Quartile*: The value that splits the lower 25% of the data when arranged in ascending order
- *median*: Middle value in the ascendingly ordered dataset
- *mean*: Sum of all values in the dataset divided by the total number of values
- *sd*: Measure of the dispersion of dataset relative to its mean.
- *3rd Quartile*: The value that splits the lower 75% of the data when arranged in ascending order
- *max*:  Maximum value of that feature/column
- *hist*: The basic barchart of the data distribution of a feature/column
- *n_row*: Number of rows for that feature/column
- *n_missing*: Number of missing values/NAs for that feature/column

It uses an inbuilt function called `edaPlots` to display the above-mentioned four objects.

*NOTE: The input dataset should be a data frame object and the columns should be only numeric type.*


```{r plot twotab,out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_df, output_type = 'summary', n_cols = 3)
```

</br>


```{r plot twohist,figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_df, output_type = 'histogram', n_cols = 3)
```

</br>


```{r plot twobox,figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_df, output_type = 'boxplot', n_cols = 3)
```


</br>


```{r plot twocor,figures-side, fig.show="hold", fig.width = 7, fig.height = 5, fig.align='center', warning = FALSE, message=FALSE}
edaPlots(torus_df, output_type = 'correlation', n_cols = 3)
```

</br>


</br>

**Train - Test Split**

Let us split the torus dataset into train and test. We will randomly select 80% of the data as train and remaining as test.


```{r train-test torus,warning=FALSE,message=FALSE,eval = global_var}
smp_size <- floor(0.80 * nrow(torus_df))
set.seed(279)
train_ind <- sample(seq_len(nrow(torus_df)), size = smp_size)
torus_train <- torus_df[train_ind, ]
torus_test <- torus_df[-train_ind, ]
```


**Training Dataset**

Now, lets have a look at the selected **training dataset** containing (9600 data points). For the sake of brevity we are displaying first six rows.

```{r torus head, warning=FALSE, eval = global_var}
rownames(torus_train) <- NULL
Table(head(torus_train))
```

Now lets have a look at **structure** of the training data.

```{r train torus structure, warning=FALSE, eval = global_var}
str(torus_train)
```

**Data Distribution**

```{r plot onetab, warning = FALSE, message=FALSE}
edaPlots(torus_train, n_cols = 3, output_type = "summary")
```


</br>


```{r plot onehist, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_train, n_cols = 3, output_type = "histogram")
```


</br>


```{r plot onebox, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_train, n_cols = 3, output_type = "boxplot")
```


</br>


```{r plot onecorr, figures-side, fig.show="hold", fig.width = 7, fig.height = 5, fig.align='center', warning = FALSE, message=FALSE}
edaPlots(torus_train, n_cols = 3, output_type = "correlation")
```

**Testing Dataset**

Now, lets have a look at **testing dataset containing(2400 data points)**.For the sake of brevity we are displaying first six rows.


```{r torus 2 head, warning=FALSE, eval = global_var}
rownames(torus_test) <- NULL
Table(head(torus_test))
```

Now lets have a look at **structure** of the test data.

```{r torus test structure, warning=FALSE, eval = global_var}
str(torus_test)
```

**Data Distribution**

```{r torus test summarytab, warning = FALSE, message=FALSE}
edaPlots(torus_test,n_cols = 3, output_type = "summary")
```

</br>


```{r torus test summaryhist, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_test,n_cols = 3, output_type = "histogram")
```

</br>


```{r torus test summarybox, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_test,n_cols = 3, output_type = "boxplot")
```


</br>

```{r torus test summarycorr, figures-side, fig.show="hold", fig.width = 7, fig.height = 5, fig.align='center', warning = FALSE, message=FALSE}
edaPlots(torus_test,n_cols = 3, output_type = "correlation")
```

## 7.1 Step 1: Data Compression

**Note: The steps of compression, projection, and tessellation are iteratively performed until a minimum compression rate of 80% is achieved. Once the desired compression is attained, the resulting model object is used for scoring using the scoreHVT() function**

The core function for compression in the workflow is `HVQ`, which is called within the `trainHVT` function. we have a parameter called quantization error. This parameter acts as a threshold and determines the number of levels in the hierarchy. It means that, if there are 'n' number of levels in the hierarchy, then all the clusters formed till this level will have quantization error equal or greater than the threshold quantization error. The user can define the number of clusters in the first level of hierarchy and then each cluster in first level is sub-divided into the same number of clusters as there are in the first level. This process continues and each group is divided into smaller clusters as long as the threshold quantization error is met. The output of this technique will be hierarchically arranged vector quantized data.

However, let's try to comprehend the **trainHVT function** first before moving on. 

 
```{r trainHVT function, echo = TRUE, eval= FALSE}
trainHVT(
  data,
  min_compression_perc,
  n_cells,
  depth,
  quant.err,
  normalize = TRUE,
  distance_metric = c("L1_Norm", "L2_Norm"),
  error_metric = c("mean", "max"),
  quant_method = c("kmeans", "kmedoids"),
  dim_reduction_method = c("sammon" , "tsne" , "umap")
  scale_summary = NA,
  diagnose = FALSE,
  hvt_validation = FALSE,
  train_validation_split_ratio = 0.8,
  projection.scale,
  tsne_perplexity,tsne_theta,tsne_verbose,
  tsne_eta,tsne_max_iter,
  umap_n_neighbors,umap_min_dist
)
```

Each of the parameters of trainHVT function have been explained below:

* __`data`__ - A dataframe, with numeric columns (features) that will be used for training the model.

* __`min_compression_perc`__ - An integer, indicating the minimum compression percentage to be achieved for the dataset. It indicates the desired level of reduction in dataset size compared to its original size.

* __`n_cells`__  - An integer, indicating the number of cells per hierarchy (level). This parameter determines the granularity or level of detail in the hierarchical vector quantization.

* __`depth`__   - An integer, indicating the number of levels. A depth of 1 means no hierarchy (single level), while higher values indicate multiple levels (hierarchy).

* __`quant.err`__ - A number indicating the quantization error threshold. A cell will only breakdown into further cells if the quantization error of the cell is above the defined quantization error threshold.

* __`normalize`__	- A logical value indicating if the dataset should be normalized. When set to TRUE, scales the values of all features to have a mean of 0 and a standard deviation of 1 (Z-score)

* __`distance_metric`__	- The distance metric can be `L1_Norm`(Manhattan) or `L2_Norm`(Euclidean). `L1_Norm` is selected by default. The distance metric is used to calculate the distance between a datapoint and its centroid. 

* __`error_metric`__ - The error metric can be `mean` or `max`. `max` is selected by default. `max` will return the max of `m` values and `mean` will take mean of `m` values where each value is a distance between a point and centroid of the cell.

* __`quant_method`__ - The quantization method can be `kmeans` or `kmedoids`. Kmeans uses means (centroids) as cluster centers while Kmedoids uses actual data points (medoids) as cluster centers. `kmeans` is selected by default.

* __`dim_reduction_method`__ - The dimensionality reduction method to be chosen. options are 'tsne' , 'umap' & 'sammon'. Default is 'sammon'. 
    
* __`scale_summary`__ -  A list with user defined mean and standard deviation values for all the features in the dataset. Pass the scale summary when normalize is set to FALSE.

* __`diagnose`__ - A logical value indicating whether user wants to perform diagnostics on the model. Default value is FALSE. 

* __`hvt_validation`__ - A logical value indicating whether user wants to holdout a validation set and find mean absolute deviation of the validation points from the centroid. Default value is FALSE.

* __`train_validation_split_ratio`__ - A numeric value indicating train validation split ratio. This argument is only used when hvt_validation has been set to TRUE. Default value for the argument is 0.8.

* __`projection.scale`__ - A number indicating the scale factor for the tessellations to visualize the sub-tessellations well enough. It helps in adjusting the visual representation of the hierarchy to make the sub-tessellations more visible. Default is 10.

* __`tsne_perplexity`__ - A numeric, balances the attention t-SNE gives to local and global    aspects of the data. Lower values focus more on local structure, while higher values consider more global structure. It is recommended to be between 5 and 50. Default value is 30.


* __`tsne_theta`__ - A numeric, speed/accuracy trade-off parameter for Barnes-Hut approximation. If set to 0, exact t-SNE is performed, which is slower. If set to greater than 0, an approximation is used, which speeds up the process but may reduce accuracy. Default value is 0.5


* __`tsne_eta (learning_rate)`__ - A numeric, learning rate for t-SNE optimization.Determines the step size during optimization. If too low, the algorithm might get stuck in local minima; if too high, the solution may         become unstable. Default value is 200.


* __`tsne_max_iter`__ - An integer, maximum number of iterations. Number of iterations for the optimization process. More iterations can improve results but increase computation time. Default value is 1000.

* __`umap_n_neighbors`__  - An integer, the size of the local neighborhood (in terms of number of neighboring sample points) used for manifold approximation, controls the balance  between local and global structure in the data, smaller values focus on local structure, while larger values capture more global structures. Default value is 15.

* __`umap_min_dist`__  - A numeric, the minimum distance between points in the embedded space, controls how tightly UMAP packs points together, lower values result in a more clustered embedding. Default value is 0.1

The output of trainHVT function (list of 7 elements) have been explained below with an image attached for clear understanding.

**NOTE: Here the attached image is the snapshot of output list generated from iteration 1 which can be referred later in this section**

```{r trainhvt list,echo=FALSE,warning=FALSE,fig.show='hold',message=FALSE,fig.cap='Figure 3: The Output list generated by trainHVT function.', out.width="50%", out.height=  "20%", fig.align='center'}
knitr::include_graphics('./pngs/hvt_results_list.png')
```

* The '1st element' is a list containing information related to plotting tessellations. This information might include coordinates, boundaries, or other details necessary for visualizing the tessellations

* The '2nd element' is a list containing information related to Sammon's projection coordinates of the data points in the reduced-dimensional space.

* The '3rd element'  is a list containing detailed information about the hierarchical vector quantized data along with a summary section containing no of points, Quantization Error and the centroids for each cell for 2D.

* The '4th element'  is a list that contains all the diagnostics information of the model when diagnose is set to TRUE. Otherwise NA.

* The '5th element' is a list that contains all the information required to generates a Mean Absolute Deviation (MAD) plot, if hvt_validation is set to TRUE. Otherwise NA 

* The '6th element'  is a list containing detailed information about the hierarchical vector quantized data along with a summary section containing no of points, Quantization Error and the centroids for each cell which is the output of `hvq`.

* The '7th element' (model info) is a list that contains model generated timestamp, input parameters passed to the model, validation results and the dimensionality reduction evaluation metrics table.

We will use the `trainHVT` function to compress our data while preserving essential features of the dataset. Our goal is to achieve data compression upto atleast `80%`. In situations where the compression ratio does not meet the desired target, we can explore adjusting the model parameters as a potential solution. This involves making modifications to parameters such as the `quantization error threshold` or `increasing the number of cells` and then rerunning the trainHVT function again.

**In our example we will iteratively increase the number of cells until the desired compression percentage is reached instead of increasing the quantization threshold because it may reduce the level of detail captured in the data representation**


 <span style="color:blue">Iteration 1: </span>

We will pass the below mentioned model parameters along with torus training dataset (containing 9600 datapoints) to `trainHVT` function.


**Model Parameters**

* Number of Cells at each Level = 100
* Maximum Depth = 1
* Quantization Error Threshold = 0.1
* Error Metric = Max
* Distance Metric = Euclidean
* Dimensionality Reduction method = Sammon


```{r torus hvt first,warning=FALSE,fig.show='hold',results='hide',message=FALSE,eval = global_var}
hvt.torus <- trainHVT(
  torus_train,
  n_cells = 100,
  depth = 1,
  quant.err = 0.1,
  normalize = FALSE,
  distance_metric = "L2_Norm",
  error_metric = "max",
  quant_method = "kmeans",
  dim_reduction_method = "sammon"
)

```

Let's checkout the compression summary. 

```{r compression summary torus first,warning=FALSE,eval = global_var}
displayTable(data = hvt.torus[[3]]$compression_summary,columnName = 'percentOfCellsBelowQuantizationErrorThreshold', value = 0.8, tableType = "compression")
```


**As it can be seen from the table above, none of the 100 cells have reached the quantization threshold error. Therefore we can further subdivide the cells by increasing the n_cells parameters and then see if desired compression (80%) is reached**

Let's take a look on the 1D projection of this iteration. The output of hvq from the `trainHVT` function is then passed to the `plotHVT` function, which applies Sammon's 1D using `MASS` package. The resulting 1D Sammon's points are used to determine their corresponding cell IDs and subsequently plotted in a plotly object.

```{r, warning=FALSE,message=FALSE,fig.cap='Figure 4: Sammons 1D x Cell ID plot for layer 1 shown for the 100 cells in the torus training dataset'}
plotHVT(hvt.torus, plot.type = '1D')
```


<span style="color:blue">Iteration 2: </span>

Let's retry by increasing the n_cells parameter to 300 for torus training dataset (containing 9600 datapoints).

**Model Parameters**

* Number of Cells at each Level = 300
* Maximum Depth = 1
* Quantization Error Threshold = 0.1
* Error Metric = Max
* Distance Metric = Euclidean
* Dimensionality Reduction method = Sammon


```{r torus hvt second,warning=FALSE,fig.show='hold',results='hide',message=FALSE,eval = global_var}
hvt.torus2 <- trainHVT(
  torus_train,
  n_cells = 300,
  depth = 1,
  quant.err = 0.1,
  normalize = FALSE,
  distance_metric = "L2_Norm",
  error_metric = "max",
  quant_method = "kmeans",
  dim_reduction_method = "sammon"
)

```


Let's checkout the compression summary again.

```{r compression summary torus second,warning=FALSE,eval = global_var}
displayTable(data = hvt.torus2[[3]]$compression_summary,columnName = 'percentOfCellsBelowQuantizationErrorThreshold', value = 0.8, tableType = "compression")

```
**It can be observed from the table above that only 143 cells out of 300 i.e. `48%` of the cells reached the Quantization Error threshold. Therefore we can further subdivide the cells by increasing the n_cells parameters and then see if 80% compression is reached **

```{r, warning=FALSE,message=FALSE,fig.cap='Figure 5: Sammons 1D x Cell ID plot for layer 1 shown for the 300 cells in the torus training dataset',out.width="100%", out.height="60%"}
plotHVT(hvt.torus2, plot.type = '1D')
```


<span style="color:blue">Iteration 3: </span>

Since we are yet to achieve the compression of atleast 80%, lets try again by increasing the n_cells parameter to 500 for torus training dataset (containing 9600 datapoints) .

**Model Parameters**

* Number of Cells at each Level = 500
* Maximum Depth = 1
* Quantization Error Threshold = 0.1
* Error Metric = Max
* Distance Metric = Euclidean
* Dimensionality Reduction method = Sammon


```{r torus hvt third ,warning=FALSE,fig.show='hold',results='hide',message=FALSE,eval = global_var}
set.seed(240)
hvt.torus3 <- trainHVT(
  torus_train,
  n_cells = 500,
  depth = 1,
  quant.err = 0.1,
  normalize = FALSE,
  distance_metric = "L2_Norm",
  error_metric = "max",
  quant_method = "kmeans",
  dim_reduction_method = "sammon"
)

```


Let's check the compression summary for torus.

```{r compression summary torus third,warning=FALSE,eval = global_var}
displayTable(data = hvt.torus3[[3]]$compression_summary,columnName = 'percentOfCellsBelowQuantizationErrorThreshold', value = 0.8, tableType = "compression")

```

**By increasing the number of cells to 500, we were successfully able to compress `90%` of the data, so we will not further subdivide the cells**

We successfully compressed data to 90% using n_cells parameter as 500, the next step involves performing data projection on the compressed data. In this step, the compressed data will be transformed and projected onto a lower-dimensional space to visualize and analyze the data in a more manageable form.


```{r, warning=FALSE,message=FALSE,fig.cap='Figure 6: Sammons 1D x Cell ID plot for layer 1 shown for the 500 cells in the torus training dataset',out.width="100%", out.height="60%"}
plotHVT(hvt.torus3, plot.type = '1D')
```

## 7.2 Step 2: Data Projection

This section focusses on projecting the sammon's dimensionality reduction from multi dimension to 2D. The following plots will have the centroids plotted in 2D space with x coordinate of the centroid points on X-axis and y coordinate of the centroid points on Y-axis.

Now let's try to understand **plotHVT** function. The parameters have been explained in detail below:

```{r plotHVT function,echo = TRUE, eval= FALSE}
plotHVT <-(hvt.results, line.width, color.vec, pch1, centroid.size,
           title, maxDepth, child.level, hmap.cols, centroid.color,
           quant.error.hmap, n_cells.hmap, cell_id, 
           label.size, sepration_width, layer_opacity,
           dim_size, plot.type = '2Dhvt') 
```

* __`hvt.results`__ - (1D/2Dproj/2Dhvt/2Dheatmap/surface_plot)  A list obtained from the trainHVT function. This list provides an overview of the hierarchical vector quantized data, including diagnostics, tessellation details, Sammon's projection coordinates, and model input information.

* __`line.width`__	- (2Dhvt/2Dheatmap) A vector indicating the line widths of the tessellation boundaries for each layer.

* __`color.vec`__	- (2Dhvt/2Dheatmap) A vector indicating the colors of the tessellations boundaries at each layer.

* __`pch1`__	- (2Dhvt/2Dheatmap) Symbol. It plots the centroids with a particular symbol such as (solid circle, bullet, filled square, filled diamond) in the tessellations.(default = 21 i.e filled circle).

* __`centroid.size`__	- (2Dhvt/2Dheatmap)  Vector of Size of centroids for each level of tessellations.

* __`centroid.color`__	- (2Dhvt/2Dheatmap) Vector of color of centroids for each level of tessellations.

* __`title`__	-  (2Dhvt) Set a title for the plot (default = NULL).

* __`maxDepth`__ -  (2Dhvt) An integer indicating the number of levels.

* __`cell_id`__ - (2Dhvt) Logical. To indicate whether the plot should have Cell IDs or not for the level 1. (default = FALSE)


* __`child.level`__ - (2Dheatmap/surface_plot) A Number indicating the level for which the heat map is to be plotted.

* __`hmap.cols`__ - (2Dheatmap/surface_plot) A Number or a Character which is the column number of column name from
the dataset indicating the variables for which the heat map is to be plotted.

* __`label.size`__ - (2Dheatmap) The size by which the tessellation labels should
be scaled.(default = 0.5)

* __`quant.error.hmap`__ - (2Dheatmap) A number indicating the quantization error threshold.

* __`n_cells.hmap`__ - (2Dheatmap) An integer indicating the number of cells/clusters per hierarchy 

* __`sepration_width`__ - (surface_plot) An integer indicating the width between two levels.

* __`layer_opacity`__ - (surface_plot) A vector indicating the opacity of each layer/level.

* __`dim_size`__ - (surface_plot) An integer indicating the dimension size used to create the matrix for the plot.

* __`plot.type`__ -  A Character indicating which type of plot should be generated. Accepted entries are '1D',   '2Dproj','2Dhvt','2Dheatmap' & 'surface_plot'. Default value is '2Dhvt'.

<span style="color:blue">Iteration 1: </span>

Lets see the projected Sammons 2D onto a plane with n_cell set to 100 in first iteration.

```{r, warning=FALSE,message=FALSE, fig.cap='Figure 7: Sammons 2D Plot for 100 cells',  fig.width = 7, fig.height = 5}
plotHVT(hvt.torus, plot.type = '2Dproj')
```


<span style="color:blue">Iteration 2: </span>

Lets see the projected Sammons 2D onto a plane with n_cell set to 300 in second iteration.

```{r, message=FALSE,warning=FALSE,fig.cap='Figure 8: Sammons 2D Plot for 300 cells',  fig.width = 7, fig.height = 5}
plotHVT(hvt.torus2, plot.type = '2Dproj')
```

<span style="color:blue">Iteration 3: </span>

Lets see the projected Sammons 2D onto a plane with n_cell set to 500 in third iteration.

```{r, warning=FALSE,message=FALSE,fig.cap='Figure 9: Sammons 2D Plot for 500 cells',  fig.width = 7, fig.height = 5}
plotHVT(hvt.torus3, plot.type = '2Dproj')
```

## 7.3 Step 3: Tessellation

The `deldir` package computes the Delaunay triangulation (and hence the Dirichlet or Voronoi tessellation) of a planar point set according to the second (iterative) algorithm of Lee and Schacter. For subsequent levels, transformation is performed on the 2D coordinates to get all the points within its parent tile. Tessellations are plotted using these transformed points as centroids. `plotHVT` is the main function to plot hierarchical voronoi tessellation.

<span style="color:blue">Iteration 1: </span>

To enhance visualization, let's generate a plot of the Voronoi tessellation for the **first iteration** where we set **n_cells parameter as 100**. This plot will provide a visual representation of the Voronoi regions corresponding to the data points, aiding in the analysis and understanding of the data distribution.

```{r, warning=FALSE,message=FALSE,fig.cap='Figure 10: The Voronoi tessellation for layer 1 shown for the 100 cells in the torus training dataset', fig.width = 7, fig.height = 5}
plotHVT(
  hvt.torus,
  line.width = c(0.4),
  color.vec = c("black"),
  centroid.size = 0.6,
  maxDepth = 1, 
  plot.type = '2Dhvt'
)
```

 <span style="color:blue">Iteration 2: </span>

Now, let's plot the Voronoi tessellation for the **second iteration** where we set **n_cells parameter to 300**.

```{r, warning=FALSE,message=FALSE,fig.cap='Figure 11: The Voronoi tessellation for layer 1 shown for the 300 cells in the torus training dataset', fig.width = 7, fig.height = 5}
plotHVT(
  hvt.torus2,
  line.width = c(0.4),
  color.vec = c("black"),
  centroid.size = 0.6,
  maxDepth = 1,
  plot.type = '2Dhvt'
)
```

 <span style="color:blue">Iteration 3: </span>

Now, let's plot the Voronoi tessellation again, for the **third iteration** where we set **n_cells parameter to 500**.

```{r, warning=FALSE,message=FALSE,fig.cap='Figure 12: The Voronoi tessellation for layer 1 shown for the 500 cells in the torus training dataset', fig.width = 7, fig.height = 5}
plotHVT(
  hvt.torus3,
  line.width = c(0.4),
  color.vec = c("black"),
  centroid.size = 0.6,
  maxDepth = 1,
  plot.type = '2Dhvt'
)
```

**From the presented plot, the inherent structure of the donut can be easily observed in the two-dimensional space**



### 7.3.1  Heat Maps

Now let’s plot the Voronoi Tessellation with the heatmap overlaid for all the features in the torus data for better visualization and interpretation of data patterns and distributions.

The heatmaps displayed below provides a visual representation of the spatial characteristics of the torus, allowing us to observe patterns and trends in the distribution of each of the features (x,y,z). The sheer green shades highlight regions with higher coordinate values in each of the heatmaps, while the indigo  shades indicate areas with the lowest coordinate values in each of the heatmaps. By analyzing these heatmaps, we can gain insights into the variations and relationships between each of these features within the torus structure.


```{r hmp level two quantization torus n demo,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 13: The Voronoi tessellation for layer 1 and number of cells 500 with the heat map overlaid for `No. of entities in each cell` in the torus dataset',eval = global_var, fig.width = 7, fig.height = 5}
plotHVT(
  hvt.torus3,
  child.level = 1,
  hmap.cols = "n",
  line.width = c(0.4),
  color.vec = c("black"),
  centroid.size = 0.8,
  plot.type = '2Dheatmap'
)
```

```{r hmp level two quantization torus x demo,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 14: The Voronoi tessellation for layer 1 and number of cells 500 with the heat map overlaid for variable `x` in the torus dataset',eval = global_var, fig.width = 7, fig.height = 5}
plotHVT(
  hvt.torus3,
  child.level = 1,
  hmap.cols = "x",
  line.width = c(0.4),
  color.vec = c("black"),
  centroid.size = 0.8,
  plot.type = '2Dheatmap'
)
```

```{r hmp level two quantization torus y demo,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 15: The Voronoi tessellation for layer 1 and number of cells 500 with the heat map overlaid for variable `y` in the torus dataset',eval = global_var,  fig.width = 7, fig.height = 5}
plotHVT(
  hvt.torus3,
  child.level = 1,
  hmap.cols = "y",
  line.width = c(0.4),
  color.vec = c("black"),
  centroid.size = 0.8,
  plot.type = '2Dheatmap'
)
```

```{r hmp level two quantization torus z demo,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 16: The Voronoi tessellation for layer 1 and number of cells 500 with the heat map overlaid for variable `z` in the torus dataset',eval = global_var, fig.width = 7, fig.height = 5}
plotHVT(
  hvt.torus3,
  child.level = 1,
  hmap.cols = "z",
  line.width = c(0.4),
  color.vec = c("black"),
  centroid.size = 0.8,
  plot.type = '2Dheatmap'
)
```

## 7.4 Step 4: Scoring(scoreHVT)

Let's try to comprehend the **scoreHVT function** first before moving on

```{r scoreHVT function1,echo = TRUE, eval= FALSE}
scoreHVT(dataset,
         hvt.results.model,
         child.level,
         mad.threshold,
         line.width,
         color.vec,
         normalize,
         distance_metric,
         error_metric,
         yVar,
         analysis.plots,
         names.column)
```

The parameters for the function `scoreHVT` are explained below:

* __`dataset`__ - A dataframe containing the testing dataset. The dataframe should have all the variable(features) used for training. 

* __`hvt.results.model`__ - A list obtained from the trainHVT function while performing hierarchical vector quantization on training data. This list provides an overview of the hierarchical vector quantized data, including diagnostics, tessellation details, Sammon's projection coordinates, and model input information.

* __`child.level`__ - A number indicating the depth for which the heat map is to be plotted. Each depth represents a different level of clustering or partitioning of the data.

* __`mad.threshold`__  - A numeric value indicating the permissible Mean Absolute Deviation which is obtained from Minimum Intra centroid plot(when diagnose is set to TRUE in trainHVT). `mad.threshold` value is important since it is used in anomaly detection.Default value is 0.2
*NOTE: for a given datapoint, when the quantization error is above `mad.threshold` it is denoted as anomaly else not.*

* __`line.width`__	- A vector indicating the line widths of the tessellation boundaries for each layer. (Optional Parameters)

* __`color.vec`__	- A vector indicating the colors of the tessellations boundaries at each layer. (Optional Parameters)

* __`normalize`__ - A logical value indicating if the dataset should be normalized. When set to TRUE, the data (testing dataset) is standardized by mean and sd of the training dataset referred from the trainHVT(). When set to FALSE, the `data` is used as such without any changes.

* __`distance_metric`__ - The distance metric can be `L1_Norm`(Manhattan) or `L2_Norm`(Euclidean). The metric is used when calculating distance between each datapoint(in test dataset) with the centroids obtained from results of trainHVT. Default is `L1_Norm`.

* __`error_metric`__ - The error metric can be `mean` or `max`.  `max` will return the max of `m` values and `mean` will take mean of `m` values where each value is a distance between the datapoint and centroid of the cell. This helps in calculating the scored quantization error. Default value is `max`.

* __`yVar`__ - A character or a vector representing the name of the dependent variable(s)

*The below given arguments are used only when character column can be mapped over the scored results. since torus doesn't have a character column, we are not using them in this vignette.*

* __`analysis.plots`__ - A logical value to indicate whether to include the insight plots which are useful in viewing the contents and clusters of cells. Default is FALSE.

* __`names.column`__ - The column of names of the datapoints which will be displayed as the contents of the cell in 'scoredPlotly'. Default is NULL.




Now once we have built the model, let us try to score using our testing dataset (containing 2400 data points) which cell and which level each point belongs to.

```{r scoreHVT torus,warning=FALSE,message=FALSE,eval = global_var}
set.seed(240)
scoring_torus <- scoreHVT(
  torus_test,
  hvt.torus3,
  child.level = 1,
  line.width = c(1.2),
  color.vec = c("black"),
  normalize = FALSE
)
```


Let's see which cell and level each point belongs to and check the mean absolute difference for each of the **2400 records**. For the sake of brevity, we will only show the first 100 rows



```{r}
Act_pred_Table <- scoring_torus[["scoredPredictedData"]]
rownames(Act_pred_Table) <- NULL
Act_pred_Table %>% head(100) %>%as.data.frame() %>%Table(scroll = TRUE, limit = 100)
```


```{r, warning=FALSE,message=FALSE,fig.cap='Figure 17: Mean Absolute Difference', fig.width=7, fig.height=5}
hist(Act_pred_Table$diff, breaks = 20, col = "blue", main = "Mean Absolute Difference", xlab = "Difference",xlim = c(0,0.20), ylim = c(0,500))


```

# 8. Example II: HVT with the Personal Computer dataset

**Data Understanding**

In this section, we will use the `Prices of Personal Computers` dataset. This dataset contains 6259 observations and 10 features. The dataset observes the price from 1993 to 1995 of 486 personal computers in the US. The variables are price, speed, ram, screen, cd, etc. The dataset can be downloaded from
<a href="https://github.com/Mu-Sigma/HVT/-/blob/master/vignettes/sample_dataset/Computers.csv" target="_blank">here</a>.

In this example, we will compress this dataset by using hierarchical VQ via k-means and visualize the Voronoi Tessellation plots using Sammons projection. Later on, we will overlay all the variables as a heatmap to generate further insights.

Here, we load the data and store into a variable `computers`.

```{r load data computer,warning=FALSE,message=FALSE,eval = TRUE}
computers <- read.csv("https://raw.githubusercontent.com/Mu-Sigma/HVT/master/vignettes/sample_dataset/Computers.csv")
```

**Personal Computers Dataset**

The Computers dataset includes the following columns:

* Price: The price of 486 PCs in US dollars.
* Speed: The clock speed of the PCs in MHz.
* HD: The size of the hard drive in MB.
* RAM: The size of RAM in MB.
* Screen: The size of the screen in inches.
* Ads: The number of listings for 486 PCs' prices for each month.

Let's explore the **Personal Computers Dataset containing (6259 points)**. For the sake of brevity we are displaying first six rows.


```{r sample data computer,warning=FALSE,message=FALSE,eval = TRUE}
computers <- computers[,-1]
Table(head(computers))
```

Now let's have a look at **structure** of the dataset.

```{r data structure computer,warning=FALSE,message=FALSE,eval = global_var}
str(computers)
```

Further process will be carried out after removing non-numeric columns from the dataset, since the distribution plots will take only the continuous variables and K-means is not suitable for factor variables as the sample space for factor variables is discrete. A Euclidean distance function on such a space isn’t really meaningful. Hence, we will delete the factor variables(X, cd, multi, premium, trend) in our dataset.

```{r}
computers <-computers %>% dplyr::select(-c( cd, multi, premium, trend))
```


**Data Distribution**

This section displays four objects.

**Variable Histograms**: The histogram distribution of all the features in the dataset.

**Box Plots**: Box plots for all the features in the dataset. These plots will display the median and Interquartile range of each column at a panel level.

**Correlation Matrix**: This calculates the Pearson correlation which is a bivariate correlation value measuring the linear correlation between two numeric columns. The output plot is shown as a matrix.

**Summary EDA**: The table provides descriptive statistics for all the features in the dataset.

- *variable*: The features/columns of the dataset
- *min*: Minimum value of that feature/column
- *1st Quartile*: The value that splits the lower 25% of the data when arranged in ascending order
- *median*: Middle value in the ascendingly ordered dataset
- *mean*: Sum of all values in the dataset divided by the total number of values
- *sd*: Measure of the dispersion of dataset relative to its mean.
- *3rd Quartile*: The value that splits the lower 75% of the data when arranged in ascending order
- *max*:  Maximum value of that feature/column
- *hist*: The basic barchart of the data distribution of a feature/column
- *n_row*: Number of rows for that feature/column
- *n_missing*: Number of missing values/NAs for that feature/column

It uses an inbuilt function called `edaPlots` to display the above-mentioned four objects.

*NOTE: The input dataset should be a data frame object and the columns should be only numeric type.*

```{r, computers dataset distributiontable, warning = FALSE, message=FALSE}
edaPlots(computers, output_type = 'summary', n_cols = 6)
```

```{r, computers dataset distributionhist, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(computers, output_type = 'histogram', n_cols = 6)
```

```{r, computers dataset distributionbox, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(computers, output_type = 'boxplot', n_cols = 6)
```

```{r, computers dataset distributioncor, warning = FALSE, message=FALSE,  fig.width = 7, fig.height = 5, fig.align='center'}
edaPlots(computers, output_type = 'correlation', n_cols = 6)
```

**Train - Test Split**

Let us split the computers data into train and test. We will randomly select 80% of the data as train and remaining as test.

```{r train-test computer,warning=FALSE,message=FALSE,eval = global_var}
num_rows <- nrow(computers)
set.seed(123)
train_indices <- sample(1:num_rows, 0.8 * num_rows)
trainComputers <- computers[train_indices, ]
testComputers <- computers[-train_indices, ]
```


**Training Dataset**

Now, lets have a look at the randomly selected **training dataset** containing (5007 data points). For the sake of brevity we are displaying first six rows.

```{r, warning=FALSE,message=FALSE}
trainComputers_data <- trainComputers %>% as.data.frame() %>% round(4)
trainComputers_data <- trainComputers_data %>% dplyr::select(price,speed,hd,ram,screen,ads)
row.names(trainComputers_data) <- NULL
Table(head(trainComputers_data))
```

Now let's have a look at **structure** of the training dataset.

```{r train computers structure, warning=FALSE, eval = global_var}
str(trainComputers_data)
```

**Data Distribution**

```{r plot threetab, warning = FALSE, message=FALSE }
edaPlots(trainComputers_data,output_type = 'summary', n_cols = 6)
```

```{r plot threehist, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE }
edaPlots(trainComputers_data,output_type = 'histogram', n_cols = 6)
```

```{r plot threebox, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE }
edaPlots(trainComputers_data,output_type = 'boxplot', n_cols = 6)
```

```{r plot threecorr, figures-side, fig.show="hold", warning = FALSE, message=FALSE, fig.width = 7, fig.height = 5, fig.align='center' }
edaPlots(trainComputers_data,output_type = 'correlation', n_cols = 6)
```

**Testing Dataset**

Now, lets have a look at the **testing dataset** containing (1252 data points). For the sake of brevity we are displaying first six rows.


```{r,warning=FALSE,message=FALSE}
testComputers_data <- testComputers %>% as.data.frame() %>% round(4)
testComputers_data <- testComputers_data %>% dplyr::select(price,speed,hd,ram,screen,ads)
rownames(testComputers_data) <- NULL
Table(head(testComputers_data))
```

Now let's have a look at **structure** of the testing dataset.

```{r computers structure, warning=FALSE, eval = global_var}
str(testComputers_data,output_type = 'all', n_cols = 6)
```

**Data Distribution**

```{r tab,  warning = FALSE, message=FALSE}
edaPlots(testComputers_data, output_type = "summary", n_cols = 6)
```

```{r hist, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(testComputers_data, output_type = "histogram", n_cols = 6)
```

```{r box, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(testComputers_data, output_type = "boxplot", n_cols = 6)
```

```{r corr, figures-side, fig.show="hold", warning = FALSE, message=FALSE, fig.width = 7, fig.height = 5, fig.align='center'}
edaPlots(testComputers_data, output_type = "correlation", n_cols = 6)
```

As we are familiar with the structure of the computers data, we will now follow the following steps to get the scores using the Computers dataset.

## 8.1 Step 1: Data Compression

For more detailed information on Data Compression please refer to [section 7.1](#step-1-data-compression) of this vignette.

We will use the `trainHVT` function to compress our data while preserving essential features of the dataset. Our goal is to achieve data compression upto atleast `80%`. In situations where the compression ratio does not meet the desired target, we can explore adjusting the model parameters as a potential solution. This involves making modifications to parameters such as the `quantization error threshold` or `increasing the number of cells` and then rerunning the trainHVT function again.

We will pass the below mentioned model parameters along with computers training dataset (5007) to `trainHVT` function.

**Model Parameters**

* Number of Cells at each Level = 300
* Maximum Depth = 1
* Quantization Error Threshold = 0.2
* Error Metric = Max
* Distance Metric = Euclidean
* Dimensionality Reduction method = Sammon

```{r level one computers,warning=FALSE,message=FALSE,results='asis',eval = global_var}
hvt.results <- trainHVT(trainComputers,   
                          n_cells = 300,
                          depth = 1,
                          quant.err = 0.2,
                          normalize = TRUE,
                          distance_metric = "L2_Norm",
                          error_metric = "max",
                          quant_method = "kmeans",
                          dim_reduction_method = "sammon")

```

Now let's check the compression summary. The table below shows no of cells, no of cells having quantization error below threshold and percentage of cells having quantization error below threshold for each level.

```{r compression summary level one computers,warning=FALSE,eval = global_var}
displayTable(data = hvt.results[[3]]$compression_summary,columnName = 'percentOfCellsBelowQuantizationErrorThreshold', value = 0.8, tableType = "compression")

```


**As it can be seen from the table above, __`91%`__ of the cells have reached the quantization threshold error. Since we are successfully able to attain the desired compression percentage, so we will not further subdivide the cells **

__`hvt.results[[3]]`__ gives us detailed information about the hierarchical vector quantized data.

__`hvt.results[[3]][['summary']]`__ gives a nice tabular data containing no of points, Quantization Error and the centroids.

The datatable displayed below is the summary from hvt.results showing Cell.IDs, Centroids and Quantization Error for the 300 cells.

For the sake of brevity, we are displaying only the first 100 rows.

```{r summary level one computers,warning=FALSE,eval = global_var}
displayTable(data =hvt.results[[3]][['summary']], columnName= 'Quant.Error', value = 0.2, tableType = "summary", scroll = TRUE)

```

Now let us understand what each column in the above summary table means:

* __`Segment.Level`__ - Layers of the cell. In this case, we have performed Vector Quantization for depth 1. Hence Segment Level is 1

* __`Segment.Parent`__ - Parent segment of the cell

* __`Segment.Child (Cell.Number)`__ - The children of a particular cell. In this case, it is the total number of cells at which we achieved the defined compression percentage

* __`n`__ - No of points in each cell

* __`Cell.ID`__ - Cell_ID’s are generated for the multivariate data using 1-D Sammon’s Projection algorithm

* __`Quant.Error`__ - Quantization Error for each cell

All the columns after this will contain centroids for each cell. They can also be called a codebook, which represents a collection of all centroids or codewords.

```{r, warning=FALSE,message=FALSE,fig.cap='Figure 18: Sammons 1D x Cell ID plot for layer 1 shown for the 300 cells in the dataset ’computers’',out.width="100%", out.height="60%"}
plotHVT(hvt.results, plot.type = '1D')
```



## 8.2 Step 2: Data Projection

For more detailed information on Data Projection please refer to [section 7.2](#step-2-data-projection) of this vignette.


Lets visualize the projected Sammons 2D for n_cell set to 300 onto a plane.

```{r, warning=FALSE,message=FALSE,fig.cap='Figure 19: Sammons 2D Plot for 300 cells', fig.width = 7, fig.height = 5}
plotHVT(hvt.results, plot.type = '2Dproj')
```

## 8.3 Step 3: Tessellation

For more detailed information on voronoi tessellation please refer to [section 7.3](#step-3-tessellation) of this vignette.

For better visualisation, let's plot the Voronoi tessellation using the `plotHVT` function.

```{r plot level one computers,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 20: The Voronoi Tessellation for layer 1 shown for the 300 cells in the dataset ’computers’',eval = global_var,  fig.width = 7, fig.height = 5}
plotHVT(hvt.results,
        line.width = c(0.2), 
        color.vec = c("black"),
        centroid.size = 0.01,  
        maxDepth = 1,
        plot.type = '2Dhvt')


```    


###  8.3.1  Heat Maps

Now let's plot the Voronoi Tessellation with the heatmap overlaid for all the features in the computers dataset for better visualization.

The heatmaps displayed below provides a visual representation of the spatial characteristics of the computers data, allowing us to observe patterns and trends in the distribution of each of the features (price,speed,hd,ram,screen,ads). The sheer green  shades highlight regions with higher values in each of the heatmaps, while the indigo shades indicate areas with the lowest  values in each of the heatmaps. By analyzing these heatmaps, we can gain insights into the variations and relationships between each of these features within the computers data


```{r hmp level one n computers,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 21: The Voronoi Tessellation with the heat map overlaid over the `No. of entities in each cell` in the ’computers’ dataset',eval = global_var,  fig.width = 7, fig.height = 5}
plotHVT(
  hvt.results,
  child.level = 1,
  hmap.cols = "n",
  line.width = c(0.2),
  color.vec = c("black"),
  centroid.size = 0.03,
  plot.type = '2Dheatmap'
)
```

```{r hmp level one price computers,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 22: The Voronoi Tessellation with the heat map overlaid over the variable `price` in the ’computers’ dataset',eval = global_var,  fig.width = 7, fig.height = 5}

plotHVT(
  hvt.results,
  child.level = 1,
  hmap.cols = "price",
  line.width = c(0.2),
  color.vec = c("black"),
  centroid.size = 0.03,
  plot.type = '2Dheatmap'
)
```

```{r hmp level one hd computers,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 23: The Voronoi Tessellation with the heat map overlaid over the variable `hd` in the ’computers’ dataset',eval = global_var,  fig.width = 7, fig.height = 5}

plotHVT(
  hvt.results,
  child.level = 1,
  hmap.cols = "hd",
  line.width = c(0.2),
  color.vec = c("black"),
  centroid.size = 0.03,
  plot.type = '2Dheatmap'
)

```

```{r hmp level one ram computers,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 24: The Voronoi Tessellation with the heat map overlaid over the variable `ram` in the ’computers’ dataset',eval = global_var,  fig.width = 7, fig.height = 5}
plotHVT(
  hvt.results,
  child.level = 1,
  hmap.cols = "ram",
  line.width = c(0.2),
  color.vec = c("black"),
  centroid.size = 0.03,
  plot.type = '2Dheatmap'
)
```

```{r hmp level one screen computers,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 25: The Voronoi Tessellation with the heat map overlaid over the variable `screen` in the ’computers’ dataset',eval = global_var,  fig.width = 7, fig.height = 5}
plotHVT(
  hvt.results,
  child.level = 1,
  hmap.cols = "screen",
  line.width = c(0.2),
  color.vec = c("black"),
  centroid.size = 0.03,
  plot.type = '2Dheatmap'
)

```

```{r hmp level one ads computers,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 26: The Voronoi Tessellation with the heat map overlaid over the variable `ads` in the ’computers’ dataset',eval = global_var,  fig.width = 7, fig.height = 5}

plotHVT(
  hvt.results,
  child.level = 1,
  hmap.cols = "ads",
  line.width = c(0.2),
  color.vec = c("black"),
  centroid.size = 0.03,
  plot.type = '2Dheatmap'
)

```

## 8.4 Step 4: Scoring(scoreHVT)

For more detailed information on scoring please refer to [section 7.4](#step-4-scoringscorehvt) of this vignette.

Now once we have built the model, let us try to score using our testing dataset containing(1252 data points) which cell and which level each point belongs to.


```{r scoreHVT function,echo = TRUE, eval= FALSE}
scoreHVT(dataset,
         hvt.results.model,
         child.level,
         mad.threshold,
         line.width,
         color.vec,
         normalize,
         seed,
         distance_metric,
         error_metric,
         yVar,
         analysis.plots,
         names.column)
```

The parameters for the function `scoreHVT` are explained below:

* __`dataset`__ - A dataframe containing the testing dataset. The dataframe should have all the variable(features) used for training. 

* __`hvt.results.model`__ - A list obtained from the trainHVT function while performing hierarchical vector quantization on training data. This list provides an overview of the hierarchical vector quantized data, including diagnostics, tessellation details, Sammon's projection coordinates, and model input information.

* __`child.level`__ - A number indicating the depth for which the heat map is to be plotted. Each depth represents a different level of clustering or partitioning of the data.

* __`mad.threshold`__  - A numeric value indicating the permissible Mean Absolute Deviation which is obtained from Minimum Intra centroid plot(when diagnose is set to TRUE in trainHVT). `mad.threshold` value is important since it is used in anomaly detection.Default value is 0.2
*NOTE: for a given datapoint, when the quantization error is above `mad.threshold` it is denoted as anomaly else not.*

* __`line.width`__	- A vector indicating the line widths of the tessellation boundaries for each layer. (Optional Parameters)

* __`color.vec`__	- A vector indicating the colors of the tessellations boundaries at each layer. (Optional Parameters)

* __`normalize`__ - A logical value indicating if the dataset should be normalized. When set to TRUE, the data (testing dataset) is standardized by mean and sd of the training dataset referred from the trainHVT(). When set to FALSE, the `data` is used as such without any changes.

* __`distance_metric`__ - The distance metric can be `L1_Norm`(Manhattan) or `L2_Norm`(Euclidean). The metric is used when calculating distance between each datapoint(in test dataset) with the centroids obtained from results of trainHVT. Default is `L1_Norm`.

* __`error_metric`__ - The error metric can be `mean` or `max`.  `max` will return the max of `m` values and `mean` will take mean of `m` values where each value is a distance between the datapoint and centroid of the cell. This helps in calculating the scored quantization error. Default value is `max`.

* __`yVar`__ - A character or a vector representing the name of the dependent variable(s)

*The below given arguments are used only when character column can be mapped over the scored results. since torus doesn't have a character column, we are not using them in this vignette.*

* __`analysis.plots`__ - A logical value to indicate whether to include the insight plots which are useful in viewing the contents and clusters of cells. Default is FALSE.

* __`names.column`__ - The column of names of the datapoints which will be displayed as the contents of the cell in 'scoredPlotly'. Default is NULL.




```{r scoreHVT hmap computers,warning=FALSE,message=FALSE,eval = global_var}
set.seed(240)
scoring_comp <-scoreHVT(
  testComputers,
  hvt.results,
  child.level = 1,
  normalize = TRUE
)
```

**When normalize is set to TRUE while using scoreHVT, the function has an inbuilt feature to standardize the  testing dataset based on the mean and standard deviation of the training dataset from the trainHVT results.**

* Steps involved in Normalizing the data:
* From the trainHVT result’s list variable (here it is hvt.results) the summary is accessed which is the third list object.
* From the summary list, the scale.summary object is accessed which have two entries that stores mean_data and std_data of all the columns in training dataset.
* Those two entries are taken for the center and scale parameter in scale() which normalizes the testing dataset similar to training dataset
* This approach ensures that the model that is evaluated on testing dataset scaled in the same way as the training dataset, maintaining consistency and improving the model’s ability to generalize to new, unseen data.

Let's see which cell and level each point belongs to and check the mean absolute difference of each of the **1252 records**. For the sake of brevity, we will only show the first 100 rows.

```{r}
Act_pred_Table <- scoring_comp[["actual_predictedTable"]]
rownames(Act_pred_Table) <- NULL
Act_pred_Table %>% head(100) %>%as.data.frame() %>%Table(scroll = TRUE, limit = 100)
```


```{r,message=FALSE,warning=FALSE,fig.cap='Figure 27: Mean Absolute Difference', fig.width=7, fig.height=5}
hist(Act_pred_Table$diff, breaks = 20, col = "blue", main = "Mean Absolute Difference", xlab = "Difference",xlim = c(0,0.6), ylim = c(0,250))
```

# 9. Executive Summary

* **Example I: HVT with the Torus dataset**

*  We have considered torus dataset for multidimensional data visualization using Sammons projection.

*  We have randomly selected 9600 datapoints for training and remaining datapoints for validation.

*  Our goal is to achieve data compression upto atleast `80%`

* We constructed a compressed HVT map (hvt.torus) by applying the trainHVT() on the torus dataset. We set the parameters as   follows: `n_cells = 100`, `quant.error = 0.1`, and `depth = 1`. Upon analyzing the compression summary, we found that none    of the  100 cells has the quantization error below the threshold.

* We created another compressed HVT map (hvt.torus2) using the trainHVT() algorithm on the torus dataset. This time, we adjusted     the parameters to `n_cells = 300`, `quant.error = 0.1`, and `depth = 1`. After examining the compression summary, we          discovered that 48% of the cells have reached the quantization threshold error.

* Once again, we generated a compressed HVT map (hvt.torus3) using the trainHVT() algorithm on the torus dataset. The parameters for this map were set to `n_cells = 500`, `quant.error = 0.1`, and `depth = 1`. Upon analyzing the compression summary, we    found that 90% of the 100 cells have reached the quantization threshold error and we can clearly visualize the 3D torus(donut) in 2D   space.

* **Example II: HVT with the Personal Computer dataset**

*  We have considered Computer dataset for multidimensional data visualization using Sammons projection.

*  We have randomly selected 80% of datapoints for training and rest for validation.

*  Our goal is to achieve data compression upto atleast `80%`

*  We construct a compressed HVT map using the trainHVT() on the training dataset by setting __`n_cells`__ to 300 and  __`quant.error`__ to 0.2, and we were able to attain a compression of 91%

* We then plot the Voronoi Tessellation with the heatmap overlaid for all the features in the computers dataset for better visualization

* Next, we pass the validation dataset along with the HVT map obtained from `trainHVT()` to `scoreHVT()`  to see which cell and level each   point belongs to

# 10. Applications 

1. Pricing Segmentation - The package can be used to discover groups of similar customers based on the customer spend pattern and understand price sensitivity of customers

2. Market Segmentation - The package can be helpful in market segmentation where we have to identify micro and macro segments. The method used in this package can do both kinds of segmentation in one go

3. Anomaly Detection - This method can help us categorize system behavior over time and help us find anomaly when there are changes in the system. For e.g. Finding fraudulent claims in healthcare insurance

4. The package can help us understand the underlying structure of the data. Suppose we want to analyze a curved surface such as sphere or vase, we can approximate it by a lot of small low-order polygons in the form of tessellations using this package

5. In biology, Voronoi diagrams are used to model a number of different biological structures, including cells and bone microarchitecture

6. Using the base idea of Systems Dynamics, these diagrams can also be used to depict customer state changes over a period of time


# 11. References

1. <a href="https://users.ics.aalto.fi/jhollmen/dippa/node9.html" target="_blank">Topology Preserving Maps</a>

2. <a href="https://ocw.mit.edu/courses/6-450-principles-of-digital-communications-i-fall-2006/resources/book_3/" target="_blank">Vector Quantization</a>

3. <a href="https://en.wikipedia.org/wiki/K-means_clustering" target="_blank">K-means</a>

4. <a href="https://en.wikipedia.org/wiki/Sammon_mapping" target="_blank">Sammon's Projection</a>

5. <a href="https://en.wikipedia.org/wiki/Centroidal_Voronoi_tessellation" target="_blank">Voronoi Tessellations</a>




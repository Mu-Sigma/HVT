---
title: "HVT Scoring Cells with Layers using scoreLayeredHVT"
author: "Zubin Dowlaty, Srinivasan Sudarsanam, Somya Shambhawi, Vishwavani"
date: "`r Sys.Date()`"
fig.height: 4
fig.width: 15
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth : 2
vignette: >
  %\VignetteIndexEntry{HVT Scoring Cells with Layers using scoreLayeredHVT}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{css, echo=FALSE}
/* CSS for floating TOC on the left side */
#TOC {
    /* float: left; */
    position: fixed;
    margin-left: -22vw;
    width: 18vw;
    height: fit-content;
    overflow-y: auto;
    padding-top: 20px;
    padding-bottom: 20px;
    background-color: #f9f9f9;
    border-right: 1px solid #ddd;
    margin-top: -10em; 
}
.main-container {
  margin-left: 222px; /* Adjust this value to match the width of the TOC + some margin */
}
body{
max-width:1200px;
width: 50%;
}
p {
text-align: justify;
}
.caption {
  text-align: center;
}
li {
  padding-bottom: 5px;
}
ul {
  margin-bottom: 0px !important;
}
```



# 1. Abstract

The HVT package is a collection of R functions to facilitate building <a href="https://link.springer.com/chapter/10.1007/1-84628-118-0_7" target="_blank">topology preserving maps </a> for rich multivariate data analysis. Tending towards a big data preponderance, a large number of rows. A collection of R functions for this typical workflow is organized below:

1.  **Data Compression**: Vector quantization (VQ), HVQ (hierarchical vector quantization) using means or medians. This step compresses the rows (long data frame) using a compression objective.

2.  **Data Projection**: Dimension projection of the compressed cells to 1D,2D or Interactive surface plot with the Sammons Non-linear Algorithm. This step creates topology preserving map (also called <a href="https://en.wikipedia.org/wiki/Embedding" target="_blank">embedding </a>) coordinates into the desired output dimension.

3.  **Tessellation**: Create cells required for object visualization using the Voronoi Tessellation method, package includes heatmap plots for hierarchical Voronoi tessellations (HVT). This step enables data insights, visualization, and interaction with the topology preserving map. Useful for semi-supervised tasks.

4.  **Scoring**: Scoring new data sets and recording their assignment using the map objects from the above steps, in a sequence of maps if required.

5. **Temporal Analysis and Visualization**: A Collection of new functions that leverages the capacity of the HVT package by analyzing time series data for its underlying patterns, calculation of transitioning probabilities and the visualizations for the flow of data over time.

# 2. Notebook Requirements

This chunk verifies the installation of all the necessary packages to successfully run this vignette, if not, installs them and attach all the packages in the session environment.

```{r, warning=FALSE, message=FALSE}
list.of.packages <- c("plyr", "dplyr", "reactable", "kableExtra", "geozoo",
                      
                      "plotly", "purrr", "data.table", "gridExtra", "tidyr","HVT")

new.packages <-list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
if (length(new.packages))
  install.packages(new.packages, dependencies = TRUE, repos='https://cloud.r-project.org/')
invisible(lapply(list.of.packages, library, character.only = TRUE))
```


# 3. Example : HVT with the Torus dataset

**In this section, we will see how we can use the package to visualize multidimensional data by projecting them to two dimensions using Sammon's projection and further used for Scoring.**

**Data Understanding**

First of all, let us see how to generate data for torus. We are using a library `geozoo` for this purpose. Geo Zoo (stands for Geometric Zoo) is a compilation of geometric objects ranging from three to 10 dimensions. Geo Zoo contains regular or well-known objects, eg cube and sphere, and some abstract objects, e.g. Boy's surface, Torus and Hyper-Torus. 

Here, we will generate a 3D torus (a torus is a surface of revolution generated by revolving a circle in three-dimensional space one full revolution about an axis that is coplanar with the circle) with 12000 points.

**Raw Torus Dataset**

The torus dataset includes the following columns:

* x: This column represents the X-coordinate of each point in the torus.
* y: This column represents the Y-coordinate of each point in the torus.
* z: This column represents the Z-coordinate of each point in the torus.

Lets, explore the **torus dataset containing 12000 points**. For the sake of brevity we are displaying first 6 rows.

```{r torus generate,warning=FALSE,message=FALSE}
set.seed(240)
# Here p represents dimension of object, n represents number of points
torus <- geozoo::torus(p = 3,n = 12000)
torus_df <- data.frame(torus$points)
colnames(torus_df) <- c("x","y","z")
torus_df <- torus_df %>% round(4)
displayTable(head(torus_df))
```


Now let's have a look at **structure** of the torus dataset.

```{r, message=FALSE, warning=FALSE}
str(torus_df)
```

**Data distribution**

This section displays four objects.

**Variable Histograms**: The histogram distribution of all the features in the dataset.

**Box Plots**: Box plots for all the features in the dataset. These plots will display the median and Interquartile range of each column at a panel level.

**Correlation Matrix**: This calculates the Pearson correlation which is a bivariate correlation value measuring the linear correlation between two numeric columns. The output plot is shown as a matrix.

**Summary EDA**: The table provides descriptive statistics for all the features in the dataset.

- *variable*: The features/columns of the dataset
- *min*: Minimum value of that feature/column
- *1st Quartile*: The value that splits the lower 25% of the data when arranged in ascending order
- *median*: Middle value in the ascendingly ordered dataset
- *mean*: Sum of all values in the dataset divided by the total number of values
- *sd*: Measure of the dispersion of dataset relative to its mean.
- *3rd Quartile*: The value that splits the lower 75% of the data when arranged in ascending order
- *max*:  Maximum value of that feature/column
- *hist*: The basic barchart of the data distribution of a feature/column
- *n_row*: Number of rows for that feature/column
- *n_missing*: Number of missing values/NAs for that feature/column

It uses an inbuilt function called `edaPlots` to display the above-mentioned four objects.

```{r torustab, warning=FALSE, message=FALSE}
edaPlots(torus_df, output_type = "summary", n_cols = 3)
```

```{r twohisst, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_df, output_type = "histogram", n_cols = 3)
```

```{r plot twobox,figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_df, output_type = "boxplot", n_cols = 3)
```

```{r plot twocor,figures-side, fig.show="hold", fig.width = 7, fig.height = 5, fig.align='center', warning = FALSE, message=FALSE}
edaPlots(torus_df, output_type = "correlation", n_cols = 3)
```

**Train - Test Split**

Let us split the torus dataset into train and test. We will randomly select 80% of the torus dataset as train and remaining as test.

```{r train-test torus,warning=FALSE,message=FALSE}
smp_size <- floor(0.80 * nrow(torus_df))
set.seed(279)
train_ind <- sample(seq_len(nrow(torus_df)), size = smp_size)
torus_train <- torus_df[train_ind, ]
torus_test <- torus_df[-train_ind, ]
```


**Training Dataset**

Now, lets have a look at the selected **training dataset** containing (9600 data points). For the sake of brevity we are displaying first six rows.

```{r torus head, warning=FALSE}
rownames(torus_train) <- NULL
displayTable(head(torus_train))
```

Now lets have a look at **structure** of the training dataset.

```{r train torus structure, warning=FALSE}
str(torus_train)
```

**Data Distribution**

```{r datatab, warning=FALSE,message=FALSE}
edaPlots(torus_train, output_type = "summary", n_cols = 3)
```

```{r twothist, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_train,output_type = "histogram", n_cols = 3)
```

```{r plot twottbox,figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_train, output_type = "boxplot", n_cols = 3)
```

```{r datacorr,figures-side, fig.show="hold",fig.height=5, fig.width=7, warning=FALSE,message=FALSE,fig.align='center'}
edaPlots(torus_train, output_type = "correlation", n_cols = 3)
```

**Testing Dataset**

Now, lets have a look at **testing dataset containing(2400 data points)**.For the sake of brevity we are displaying first six rows.


```{r torus 2 head, warning=FALSE,message=FALSE}
rownames(torus_test) <- NULL
displayTable(head(torus_test))
```

Now lets have a look at **structure** of the testing dataset.

```{r torus test structure, warning=FALSE}
str(torus_test)
```

**Data Distribution**

```{r testdatatab, warning=FALSE,message=FALSE}
edaPlots(torus_test, output_type = "summary", n_cols = 3)
```

```{r twohist, figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_test,output_type = "histogram", n_cols = 3)
```

```{r plot twotbox,figures-side, fig.show="hold", out.width="30%", warning = FALSE, message=FALSE}
edaPlots(torus_test, output_type = "boxplot", n_cols = 3)
```

```{r plot twotcor,figures-side, fig.show="hold", fig.width = 7, fig.height = 5, fig.align='center', warning = FALSE, message=FALSE}
edaPlots(torus_test, output_type = "correlation", n_cols = 3)
```


# 4. Map A : Base Compressed Map

Let us try to visualize the compressed Map A from the diagram below.

```{r ,echo=FALSE,warning=FALSE,fig.show='hold',message=FALSE,fig.cap='Figure 1: Data Segregation with highlighted bounding box in red around compressed map A', out.width="65%", out.height="50%"}
knitr::include_graphics('./pngs/scoreLayeredHVT_function_mapA.png')
```

This package can perform vector quantization using the following algorithms -

-   Hierarchical Vector Quantization using k−means
-   Hierarchical Vector Quantization using k−medoids

For more information on vector quantization, refer the following <a href="https://nbviewer.org/github/Mu-Sigma/HVT/blob/master/vignettes/HVT_vignette.html" target="_blank">link</a>.


The trainHVT function constructs highly compressed hierarchical Voronoi tessellations. The raw data is first scaled and this scaled data is supplied as input to the vector quantization algorithm. The vector quantization algorithm compresses the dataset until a user-defined compression percentage rate is achieved using a parameter called quantization error which acts as a threshold and determines the compression percentage. It means that for a given user-defined compression percentage we get the 'n' number of cells, then all of these cells formed will have a quantization error less than the threshold quantization error.

Let's try to comprehend the `trainHVT` first before moving ahead.

```{r trainHVT function, echo=TRUE, eval=FALSE}
trainHVT(
  data,
  min_compression_perc,
  n_cells,
  depth,
  quant.err,
  normalize,
  distance_metric = c("L1_Norm", "L2_Norm"),
  error_metric = c("mean", "max"),
  quant_method = c("kmeans", "kmedoids"),
  dim_reduction_method = c("sammon" , "tsne" , "umap")
  scale_summary = NA,
  diagnose = FALSE,
  hvt_validation = FALSE,
  train_validation_split_ratio = 0.8,
  projection.scale,
  tsne_perplexity,tsne_theta,tsne_verbose,
  tsne_eta,tsne_max_iter,
  umap_n_neighbors,umap_min_dist
)
```

Each of the parameters of trainHVT function have been explained below:

* __`data`__ - A dataframe, with numeric columns (features) that will be used for training the model.

* __`min_compression_perc`__ - An integer, indicating the minimum compression percentage to be achieved for the dataset. It indicates the desired level of reduction in dataset size compared to its original size.

* __`n_cells`__  - An integer, indicating the number of cells per hierarchy (level). This parameter determines the granularity or level of detail in the hierarchical vector quantization.

* __`depth`__   - An integer, indicating the number of levels. A depth of 1 means no hierarchy (single level), while higher values indicate multiple levels (hierarchy).

* __`quant.err`__ - A number indicating the quantization error threshold. A cell will only breakdown into further cells if the quantization error of the cell is above the defined quantization error threshold.

* __`normalize`__	- A logical value indicating if the dataset should be normalized. When set to TRUE, scales the values of all features to have a mean of 0 and a standard deviation of 1 (Z-score)

* __`distance_metric`__	- The distance metric can be `L1_Norm`(Manhattan) or `L2_Norm`(Euclidean). `L1_Norm` is selected by default. The distance metric is used to calculate the distance between an `n` dimensional point and centroid. 

* __`error_metric`__ - The error metric can be `mean` or `max`. `max` is selected by default. `max` will return the max of `m` values and `mean` will take mean of `m` values where each value is a distance between a point and centroid of the cell.

* __`quant_method`__ - The quantization method can be `kmeans` or `kmedoids`. Kmeans uses means (centroids) as cluster centers while Kmedoids uses actual data points (medoids) as cluster centers. `kmeans` is selected by default.

* __`projection.scale`__ - A number indicating the scale factor for the tessellations to visualize the sub-tessellations well enough. It helps in adjusting the visual representation of the hierarchy to make the sub-tessellations more visible. Default is 10.

* __`dim_reduction_method`__ - The dimensionality reduction method to be chosen. options are 'tsne' , 'umap' & 'sammon'. Default is 'sammon'. 
    
* __`scale_summary`__ -  A list with user defined mean and standard deviation values for all the features in the dataset. Pass the scale summary when normalize is set to FALSE.

* __`diagnose`__ - A logical value indicating whether user wants to perform diagnostics on the model. Default value is FALSE. 

* __`hvt_validation`__ - A logical value indicating whether user wants to holdout a validation set and find mean absolute deviation of the validation points from the centroid. Default value is FALSE.

* __`train_validation_split_ratio`__ - A numeric value indicating train validation split ratio. This argument is only used when hvt_validation has been set to TRUE. Default value for the argument is 0.8.

* __`tsne_verbose`__ - A logical value which indicates the t-SNE algorithm to print detailed information about its progress to the console.

* __`tsne_perplexity`__ - A numeric, balances the attention t-SNE gives to local and global    aspects of the data. Lower values focus more on local structure, while higher values consider more global structure. It is recommended to be between 5 and 50. Default value is 30.

* __`tsne_theta`__ - A numeric, speed/accuracy trade-off parameter for Barnes-Hut approximation. If set to 0, exact t-SNE is performed, which is slower. If set to greater than 0, an approximation is used, which speeds up the process but may reduce accuracy. Default value is 0.5

* __`tsne_eta (learning_rate)`__ - A numeric, learning rate for t-SNE optimization.Determines the step size during optimization. If too low, the algorithm might get stuck in local minima; if too high, the solution may         become unstable. Default value is 200.

* __`tsne_max_iter`__ - An integer, maximum number of iterations. Number of iterations for the optimization process. More iterations can improve results but increase computation time. Default value is 1000.

* __`umap_n_neighbors`__  - An integer, the size of the local neighborhood (in terms of number of neighboring sample points) used for manifold approximation, controls the balance  between local and global structure in the data, smaller values focus on local structure, while larger values capture more global structures. Default value is 15.

* __`umap_min_dist`__  - A numeric, the minimum distance between points in the embedded space, controls how tightly UMAP packs points together, lower values result in a more clustered embedding. Default value is 0.1


The output of trainHVT function (list of 7 elements) have been explained below with an image attached for clear understanding.

**NOTE: Here the attached image is the snapshot of output list generated from map A which can be referred later in this section**

```{r trainhvt list,echo=FALSE,warning=FALSE,fig.show='hold',message=FALSE,fig.cap='Figure 2: The Output list generated by trainHVT function.', out.width="50%", out.height=  "20%", fig.align='center'}
knitr::include_graphics('./pngs/hvt_results_list_score.png')
```

* The '1st element' is a list containing information related to plotting tessellations. This information might include coordinates, boundaries, or other details necessary for visualizing the tessellations

* The '2nd element' is a list containing information related to Sammon's projection coordinates of the data points in the reduced-dimensional space.

* The '3rd element'  is a list containing detailed information about the hierarchical vector quantized data along with a summary section containing no of points, Quantization Error and the centroids for each cell for 2D.

* The '4th element'  is a list that contains all the diagnostics information of the model when diagnose is set to TRUE. Otherwise NA.

* The '5th element' is a list that contains all the information required to generates a Mean Absolute Deviation (MAD) plot, if hvt_validation is set to TRUE. Otherwise NA 

* The '6th element'  is a list containing detailed information about the hierarchical vector quantized data along with a summary section containing no of points, Quantization Error and the centroids for each cell which is the output of `hvq`.

* The '7th element' (model info) is a list that contains model generated timestamp, input parameters passed to the model, validation results and the dimensionality reduction evaluation metrics table.

We will use the `trainHVT` function to compress our data while preserving essential features of the dataset. Our goal is to achieve data compression upto atleast `80%`. In situations where the compression ratio does not meet the desired target, we can explore adjusting the model parameters as a potential solution. This involves making modifications to parameters such as the `quantization error threshold` or `increasing the number of cells` and then rerunning the trainHVT function again.

As this is already done in <a href="https://nbviewer.org/github/Mu-Sigma/HVT/blob/master/vignettes/HVT_vignette.html" target="_blank">**HVT Vignette:**</a> please refer for more information.

**Model Parameters**

* Number of Cells at each Level = 500
* Maximum Depth = 1
* Quantization Error Threshold = 0.1
* Error Metric = Max
* Distance Metric = Euclidean
* Dimensionality Reduction method = Sammon


```{r torus hvt third ,warning=FALSE,results='hide',message=FALSE}
set.seed(240)
torus_mapA <- trainHVT(
  torus_train,
  n_cells = 500,
  depth = 1,
  quant.err = 0.1,
  normalize = FALSE,
  distance_metric = "L2_Norm",
  error_metric = "max",
  quant_method = "kmeans",
  dim_reduction_method = "sammon"
)
```


Let's check the compression summary for torus.

```{r compression summary torus third,warning=FALSE}
displayTable(data = torus_mapA[[3]]$compression_summary)
```

We successfully compressed 90% of the data using n_cells parameter as 500, the next step involves performing data projection on the compressed data. In this step, the compressed data will be transformed and projected onto a lower-dimensional space to visualize and analyze the data in a more manageable form.

As per the manual, **`torus_mapA[[3]]`** gives us detailed information about the hierarchical vector quantized data. **`torus_mapA[[3]][['summary']]`** gives a nice tabular data containing no of points, Quantization Error and the codebook.

The datatable displayed below is the **summary from torus_mapA** showing Cell.ID, Centroids and Quantization Error for each of the 500 cells. For the sake of brevity, we are displaying only the first 100 rows.

```{r hvt_mapA display results, warning=FALSE, echo=TRUE}
displayTable(data =torus_mapA[[3]][['summary']])

```

Now let us understand what each column in the above table means:

-   **`Segment.Level`** - Level of the cell. In this case, we have performed Vector Quantization for depth 1. Hence Segment Level is 1.

-   **`Segment.Parent`** - Parent segment of the cell.

-   **`Segment.Child (Cell.Number)`** - The children of a particular cell. In this case, it is the total number of cells at which we achieved the defined compression percentage.

-   **`n`** - No of points in each cell.

-   **`Cell.ID`** - Cell_ID's are generated for the multivariate data using 1-D Sammon's Projection algorithm.

-   **`Quant.Error`** - Quantization Error for each cell.

All the columns after this will contain centroids for each cell. They can also be called a codebook, which represents a collection of all centroids or codewords.


Now let's try to understand **plotHVT** function. The parameters have been explained in detail below:

```{r plotHVT function,echo = TRUE, eval= FALSE}
plotHVT <-(hvt.results, line.width, color.vec, pch1, centroid.size, 
           centroid.color,title, maxDepth, child.level, hmap.cols,
           quant.error.hmap, n_cells.hmap, label.size, 
           sepration_width, layer_opacity, cell_id,
           dim_size, plot.type = '2Dhvt')
```

*  **`hvt.results`** - (1D/2Dproj/2Dhvt/2Dheatmap/surface_plot)  A list obtained from the trainHVT function while performing hierarchical vector quantization on training dataset. This list provides an overview of the hierarchical vector quantized data, including diagnostics, tessellation details, Sammon's projection coordinates, and model input information.

* **`line.width`**	- (2Dhvt/2Dheatmap) A vector indicating the line widths of the tessellation boundaries for each layer.

* **`color.vec`**	- (2Dhvt/2Dheatmap) A vector indicating the colors of the tessellations boundaries at each layer.

* **`pch1`**	- (2Dhvt/2Dheatmap) Symbol, It plots the centroids with a particular symbol such as (solid circle, bullet, filled square, filled diamond) in the tessellations.(default = 21 i.e filled circle).

* **`centroid.size`**	- (2Dhvt/2Dheatmap) Vector of Size of centroids for each level of tessellations.

* **`centroid.color`**	- (2Dhvt/2Dheatmap) Vector of color of centroids for each level of tessellations.

* **`title`**	-  (2Dhvt) Set a title for the plot (default = NULL).

* **`maxDepth`** -  (2Dhvt) An integer indicating the number of levels.

* **`cell_id`** - (2Dhvt) Logical. To indicate whether the plot should have Cell IDs or not for the level 1. (default = FALSE)

* **`child.level`** - (2Dheatmap/surface_plot) A Number indicating the level for which the heat map is to be plotted.

* **`hmap.cols`** - (2Dheatmap/surface_plot) A Number or a Character which is the column number or column name from
the dataset indicating the variables for which the heat map is to be plotted.

* **`label.size`** - (2Dheatmap) The size by which the tessellation labels should
be scaled.(default = 0.5)

* **`quant.error.hmap`** - (2Dheatmap) A number indicating the quantization error threshold.

* **`sepration_width`** - (surface_plot) An integer indicating the width between two Levels.

* **`layer_opacity`** - (surface_plot) A vector indicating the opacity of each layer/ level.

* **`dim_size`** - (surface_plot) An integer indicating the dimension size used to create the matrix for the plot.

* **`plot.type`** -  A Character indicating which type of plot should be generated. Accepted entries are '1D','2Dproj', '2Dhvt','2Dheatmap', 'surface_plot'. Default value is '2Dhvt'.



Let's plot the Voronoi tessellation for layer 1 (map A).

```{r, warning=FALSE,message=FALSE,fig.cap='Figure 3: The Voronoi Tessellation for layer 1 (map A) shown for the 500 cells in the dataset ’torus’',fig.width = 7, fig.height = 5}
plotHVT(torus_mapA,
        line.width = c(0.4), 
        color.vec = c("navy blue"),
        centroid.size = 0.01,
        maxDepth = 1,
        plot.type = "2Dhvt") 
```

## 4.1 Heatmaps

Now let's plot the Voronoi Tessellation with the heatmap overlaid for all the features in the torus dataset for better visualization and interpretation of data patterns and distributions.

The heatmaps displayed below provides a visual representation of the spatial characteristics of the torus dataset, allowing us to observe patterns and trends in the distribution of each of the features (x,y,z). The sheer green shades highlight regions with higher values in each of the heatmaps, while the indigo shades indicate areas with the lowest values in each of the heatmaps. By analyzing these heatmaps, we can gain insights into the variations and relationships between each of these features within the torus dataset.


```{r hvt_mapA hmp level x torus,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 4: The Voronoi Tessellation with the heat map overlaid for variable ’x’ in the ’torus’ dataset',fig.width = 7, fig.height = 5}
  plotHVT(
  torus_mapA,
  child.level = 1,
  hmap.cols = "x",
  line.width = c(0.2),
  color.vec = c("navy blue"),
  centroid.size = 0.1,
  plot.type = '2Dheatmap') 
```

```{r hvt_mapA hmp level y torus,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 5: The Voronoi Tessellation with the heat map overlaid for variable ’y’ in the ’torus’ dataset',fig.width = 7, fig.height = 5}
  plotHVT(
  torus_mapA,
  child.level = 1,
  hmap.cols = "y",
  line.width = c(0.2),
  color.vec = c("navy blue"),
  centroid.size = 0.1,
  plot.type = '2Dheatmap') 
```

```{r hvt_mapA hmp level z torus,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 6: The Voronoi Tessellation with the heat map overlaid for variable ’z’ in the ’torus’ dataset',fig.width = 7, fig.height = 5}
  plotHVT(
  torus_mapA,
  child.level = 1,
  hmap.cols = "z",
  line.width = c(0.2),
  color.vec = c("navy blue"),
  centroid.size = 0.1,
  plot.type = '2Dheatmap') 
```



# 5. Map B : Compressed Novelty Map

Let us try to visualize the Map B from the diagram below.

```{r ,echo=FALSE,warning=FALSE,fig.show='hold',message=FALSE,fig.cap='Figure 7: Data Segregation with highlighted bounding box in red around map B', out.width="65%", out.height="50%"}
knitr::include_graphics('./pngs/scoreLayeredHVT_function_mapB.png')
```

In this section, we will manually figure out the novelty cells from the plotted torus_mapA and store it in **identified_Novelty_cells** variable.

**Note**: For manual selecting the novelty cells from map A, one can enhance its interactivity by adding plotly elements to the code. This will transform map A into an interactive plot, allowing users to actively engage with the data. By hovering over the centroids of the cells, a tag containing segment `child` information will be displayed. Users can explore the map by hovering over different cells and selectively choose the novelty cells they wish to consider. Added an image for reference.

```{r ,echo=FALSE,warning=FALSE,fig.show='hold',message=FALSE,fig.cap='Figure 8: Manually selecting novelty cells', out.width="65%", out.height="50%"}
knitr::include_graphics('./pngs/reference.png')
```

The **`removeNovelty`** function removes the identified novelty cell(s) from the training dataset (containing 9600 datapoints) and stores those records separately.

It takes input as the cell number (Segment.Child) of the manually identified novelty cell(s) and the compressed HVT map (torus_mapA) with 500 cells. It returns a list of two items: `data with novelty`, and `data without novelty`.

*NOTE:* As we are using `torus dataset` here, the identified novelty cells given are for demo purpose.

```{r remove_novelty,results='asis', message=FALSE}
identified_Novelty_cells <<- c(273,44,61,486,185,425)   #as a example
output_list <- removeNovelty(identified_Novelty_cells, torus_mapA)
data_with_novelty <- output_list[[1]]
data_without_novelty <- output_list[[2]]
```

Let's have a look at the **data with novelty**(containing 115 records).

```{r hvt_mapB results, warning=FALSE, echo=TRUE}
novelty_data <- data_with_novelty
novelty_data$Row.No <- row.names(novelty_data)
novelty_data <- novelty_data %>% dplyr::select("Row.No","Cell.ID","Cell.Number","x","y","z")
colnames(novelty_data) <- c("Row.No","Cell.ID","Segment.Child","x","y","z")
displayTable(novelty_data)
```

```{=html}
<style>
/* Add space after the table */
table {
  margin-bottom: 20px;
}
</style>
```
## 5.1 Voronoi Tessellation with highlighted novelty cell

The **`plotNovelCells`** function is used to plot the Voronoi tessellation using the compressed HVT map (torus_mapA) containing 500 cells and highlights the identified novelty cell(s) i.e 6 cells (containing 115 records) in red on the map.

```{r compress_novelty_plot,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 9: The Voronoi Tessellation constructed using the compressed HVT map (map A) with the novelty cell(s) highlighted in red',fig.width = 7, fig.height = 5}
plotNovelCells(identified_Novelty_cells, torus_mapA,line.width = c(0.4),centroid.size = 0.01)
```

We pass the dataframe with novelty records (115 records) to trainHVT function along with other model parameters mentioned below to generate **map B** (layer2)

**Model Parameters**

-   Number of Cells at each Level = 11
-   Maximum Depth = 1
-   Quantization Error Threshold = 0.1
-   Error Metric = Max
-   Distance Metric = Euclidean
-   Dimensionality Reduction method = Sammon


```{r, message=FALSE,warning=FALSE, results='hide'}
colnames(data_with_novelty) <- c("Cell.ID","Segment.Child","x","y","z")
data_with_novelty <- data_with_novelty[,-1:-2]
mapA_scale_summary = torus_mapA[[3]]$scale_summary
torus_mapB <- trainHVT(data_with_novelty,
                  n_cells = 11,   
                  depth = 1,
                  quant.err = 0.1,
                  normalize = FALSE,
                  distance_metric = "L2_Norm",
                  error_metric = "max",
                  quant_method = "kmeans",
                  dim_reduction_method = "sammon")

```

The datatable displayed below is the **summary from map B (layer 2)** showing Cell.ID, Centroids and Quantization Error for each of the 11 cells.

```{r, message=FALSE,warning=FALSE}
displayTable(data =torus_mapB[[3]][['summary']])
```

Now let's check the compression summary for HVT (torus_mapB). The table below shows no of cells, no of cells having quantization error below threshold and percentage of cells having quantization error below threshold for each level.

```{r hvt_map_B compression summary,warning=FALSE}
displayTable(data = torus_mapB[[3]]$compression_summary)
```

**As it can be seen from the table above, `91%`** of the cells have hit the quantization threshold error.Since we are successfully able to attain the desired compression percentage, so we will not further subdivide the cells

# 6. Map C : Compressed Map without Novelty

Let us try to visualize the compressed Map C from the diagram below.

```{r ,echo=FALSE,warning=FALSE,fig.show='hold',message=FALSE,fig.cap='Figure 10:Data Segregation with highlighted bounding box in red around compressed map C', out.width="65%", out.height="50%"}
knitr::include_graphics('./pngs/scoreLayeredHVT_function_mapC.png')
```

## 6.1 Iteration 1

With the Novelties removed, we construct another hierarchical Voronoi tessellation **map C** layer 2 on the data without Novelty (containing 9485 records) and below mentioned model parameters.

**Model Parameters**

-   Number of Cells at Level 1 = 10
-   Number of Cells at Level 2 = 100 (10 x 10)
-   Maximum Depth = 2
-   Quantization Error Threshold = 0.1
-   Error Metric = Max
-   Distance Metric = Euclidean
-   Dimensionality Reduction method = Sammon


```{r,warning=FALSE,message=FALSE, results='hide'}
torus_mapC <- trainHVT(dataset  = data_without_novelty,
                  n_cells = 10,
                  depth = 2,
                  quant.err = 0.1,
                  normalize = FALSE,
                  distance_metric = "L2_Norm",
                  error_metric = "max",
                  quant_method = "kmeans",
                  dim_reduction_method = "sammon")
```

Now let's check the compression summary for HVT (torus_mapC) where n_cell was set to 15. The table below shows no of cells, no of cells having quantization error below threshold and percentage of cells having quantization error below threshold for each level.

```{r hvt_map_C compression summary,warning=FALSE}
displayTable(data = torus_mapC[[3]]$compression_summary)
```

**As it can be seen from the table above, `0%`** of the cells have hit the quantization threshold error in level 1 and **`0%`** of the cells have hit the quantization threshold error in level 2

## 6.2 Iteration 2

Since, we are yet to achive atleast 80% compression at depth 2. Let's try to compress again using the below mentioned set of model parameters and the data without novelty (containing 9485 records).

**Model Parameters**

-   Number of Cells at Level 1 = 46
-   Number of Cells at Level 2 = 2116 (46 x 46)
-   Maximum Depth = 2
-   Quantization Error Threshold = 0.1
-   Error Metric = Max
-   Distance Metric = Euclidean
-   Dimensionality Reduction method = Sammon

```{r,warning=FALSE,message=FALSE, results='hide'}
torus_mapC <- trainHVT(data_without_novelty,
                  n_cells = 46,    
                  depth = 2,
                  quant.err = 0.1,
                  normalize = FALSE,
                  distance_metric = "L2_Norm",
                  error_metric = "max",
                  quant_method = "kmeans",
                  dim_reduction_method = "sammon")
```

The datatable displayed below is the **summary from map C (layer2)**. showing Cell.ID, Centroids and Quantization Error.

```{r,message=FALSE,warning=FALSE}
displayTable(data =torus_mapC[[3]][['summary']])
```

Now let's check the **compression summary** for HVT (torus_mapC). The table below shows no of cells, no of cells having quantization error below threshold and percentage of cells having quantization error below threshold for each level.

```{r hvt_mapC compression summary,warning=FALSE}
displayTable(data = torus_mapC[[3]]$compression_summary)
```

**As it can be seen from the table above, `0%`** of the cells have hit the quantization threshold error in level 1 and **`83%`** of the cells have hit the quantization threshold error in level 2

Let's plot the Voronoi tessellation for layer 2 (map C)

```{r, warning=FALSE,message=FALSE,fig.cap='Figure 11: The Voronoi Tessellation for layer 2 (map C) shown for the 928 cells in the dataset ’torus’ at level 2',fig.width = 7, fig.height = 5}
plotHVT(torus_mapC,
        line.width = c(0.2,0.1), 
        color.vec = c("navyblue","steelblue"),
        centroid.size = 0.1,
        maxDepth = 2, 
        plot.type = '2Dhvt')
 
```


## 6.3 Heatmaps


Now let's plot all the features for each cell at level two as a heatmap for better visualization.

The heatmaps displayed below provides a visual representation of the spatial characteristics of the torus dataset, allowing us to observe patterns and trends in the distribution of each of the features (x,y,z). The sheer green shades highlight regions with higher values in each of the heatmaps, while the indigo shades indicate areas with the lowest values in each of the heatmaps. By analyzing these heatmaps, we can gain insights into the variations and relationships between each of these features within the torus dataset.




```{r hvt_mapC hmp level one x torus,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 12: The Voronoi Tessellation with the heat map overlaid for feature `x` in the ’torus’ dataset',fig.width = 7, fig.height = 5}
  plotHVT(
  torus_mapC,
  child.level = 2,
  hmap.cols = "x",
  line.width = c(0.2,0.1),
  color.vec = c("navyblue","steelblue"),
  centroid.size = 0.1,
  plot.type = '2Dheatmap') 
```



```{r hvt_mapC hmp levelonetorus,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 13: The Voronoi Tessellation with the heat map overlaid for feature `y` in the ’torus’ dataset',fig.width = 7, fig.height = 5}

  plotHVT(
  torus_mapC,
  child.level = 2,
  hmap.cols = "y",
  line.width = c(0.2,0.1),
  color.vec = c("navyblue","steelblue"),
  centroid.size = 0.1,
  plot.type = '2Dheatmap') 
```

```{r hvt_mapC hmp level one z torus,warning=FALSE,fig.show='hold',results='hide',message=FALSE,fig.cap='Figure 14: The Voronoi Tessellation with the heat map overlaid for feature `z` in the ’torus’ dataset',fig.width = 7, fig.height = 5}

  plotHVT(
  torus_mapC,
  child.level = 2,
  hmap.cols = "z",
  line.width = c(0.2,0.1),
  color.vec = c("navyblue","steelblue"),
  centroid.size = 0.1,
  plot.type = '2Dheatmap') 
```




**We now have the set of maps (map A, map B & map C) which will be used to score, which map and cell each test record is assigned to.**

# 7. Scoring

Now once we have built the model, let us try to score using our testing dataset (containing 2400 data points) which cell and which layer each point belongs to.

The **scoreLayeredHVT** function is used to score the testing dataset using the scored set of maps. This function takes an input - a testing dataset and a set of maps (map A, map B, map C).

Now, Let us understand the **`scoreLayeredHVT`** function.

```{r scoreLayeredHVT function,echo = TRUE, eval= FALSE}
scoreLayeredHVT(data,
                hvt_mapA,
                hvt_mapB,
                hvt_mapC,
                child.level = 1,
                mad.threshold = 0.2,
                normalize = TRUE,
                distance_metric="L1_Norm",
                error_metric="max",
                yVar)
```

Each of the parameters of **scoreLayeredHVT** function has been explained below:

Before that, the approach of `scoreLayeredHVT` function is to use scoreHVT function to score the test data against the given results of trainHVT which is referred as 'map' here. Hence the scoreLayeredHVT scores the test dataset against map A, B & C and further process and merge the final output. So the arguments used in scoreHVT is important here for smooth execution of function.

-   **`data`** - A dataframe containing the test dataset. The dataframe should have all the variable(features) used for training.

-   **`hvt_mapA`** - Result obtained from trainHVT function while performing hierarchical vector quantization on train data. This list containes information about the hierarchical vector quantized data along with a summary section.

-   **`hvt_mapB`** - Result obtained from trainHVT function while performing hierarchical vector quantization on data with novelty data.It is a subset of the training data obtained as a result of removeNovelty function (1st element).

-   **`hvt_mapC`** - Result obtained from trainHVT function while performing hierarchical vector quantization on data without novelty. It is a subset of the training data obtained as a result of removeNovelty function (2nd element).

-  **`child.level`** - A number indicating the depth for which the heat map is to be plotted. Each depth represents a different level of clustering or partitioning of the data.

-   **`mad.threshold`** -  A numeric value indicating the permissible Mean Absolute Deviation which is obtained from Minimum Intra centroid plot(when diagnose is set to TRUE in trainHVT). `mad.threshold` value is important since it is used in anomaly detection. Default value is 0.2
*NOTE: for a given datapoint, when the quantization error is above `mad.threshold` it is denoted as anomaly else not.*

-   **`normalize`** -  A logical value indicating if the dataset should be normalized. When set to TRUE, the data (testing dataset) is standardized by mean and sd of the training dataset referred from the trainHVT(). When set to FALSE, the `data` is used as such without any changes.


-   **`distance_metric`** - The distance metric can be `L1_Norm`(Manhattan) or `L2_Norm`(Euclidean). The metric is used when calculating distance between each datapoint(in test dataset) with the centroids obtained from results of trainHVT. Default is `L1_Norm`.

-   **`error_metric`** - The error metric can be `mean` or `max`.  `max` will return the max of `m` values and `mean` will take mean of `m` values where each value is a distance between the datapoint and centroid of the cell. This helps in calculating the scored quantization error. Default value is `max`.

-   **`yVar`** - A character or a vector representing the name of the dependent variable(s)



**When normalize is set to TRUE, the scoreHVT function has an inbuilt feature to standardize the  testing dataset based on the mean and standard deviation of the training dataset from the trainHVT results.**

* Steps involved in Normalizing the data:
* From the trainHVT results (here it is torus_mapA, torus_mapB & torus_mapC) the summary is accessed which is the third list object.
* From the summary list, the scale.summary object is taken which have two entries that stores mean_data and std_data of all the columns in training dataset.
* Those two entries are taken for the center and scale parameter in scale() which normalizes the testing dataset similar to training dataset in scoreHVT()
* Here in `scoreLayeredHVT` function the testing dataset is scored against all the maps (A, B & C) by using scoreHVT function and the results are merged and further processed.
* This approach ensures that the model that is evaluated on testing dataset scaled in the same way as the training dataset, maintaining consistency and improving the model’s ability to generalize to new, unseen data.


The function score based on the HVT maps - map A, map B and map C, constructed using trainHVT function. For each test record, the function will assign that record to Layer1 or Layer2. Layer1 contains the cell ids from map A and Layer 2 contains cell ids from map B (novelty map) and map C (map without novelty).

**Scoring Algorithm**

The Scoring algorithm recursively calculates the distance between each point in the testing dataset and the cell centroids for each level. The following steps explain the scoring method for a single point in the test dataset:

1.  Calculate the distance between the point and the centroid of all the cells in the first level.
2.  Find the cell whose centroid has minimum distance to the point.
3.  Check if the cell drills down further to form more cells.
4.  If it doesn't, return the path. Or else repeat steps 1 to 4 till we reach a level at which the cell doesn't drill down further.

**Note : The Scoring algorithm will not work if some of the variables used to perform quantization are missing. In the testing dataset, we should not remove any features.**

```{r, message=FALSE,warning=FALSE}
validation_data <- torus_test
new_score <- scoreLayeredHVT(
    data=validation_data,
    hvt_mapA = torus_mapA,
    hvt_mapB = torus_mapB,
    hvt_mapC = torus_mapC,
    normalize = FALSE )
```

Let's see which cell and layer each point belongs to and check the Mean Absolute Difference for each of the **2400 records**. For the sake of brevity, we are only displaying the first 100 rows.

```{r}
displayTable(new_score[["actual_predictedTable"]])
```

```{r,message=FALSE,warning=FALSE,fig.cap='Figure 16: Mean Absolute Difference',fig.width = 7, fig.height = 5}
hist(new_score[["actual_predictedTable"]]$diff, breaks = 30, col = "blue", main = "Mean Absolute Difference", xlab = "Difference")
```

# 8. Executive Summary

-   We have considered torus dataset for creating a scored sequence of maps using scoreLayeredHVT() in this vignette.

-   Our goal is to achieve data compression upto atleast `80%`.

-   We construct a compressed HVT map (torus_mapA) using the trainHVT() on the training dataset by setting **`n_cells`** to 500 and **`quant.error`** to 0.1 and we were able to attain a compression of 90%.

-   Based on the output of the above step, we manually identify the novelty cell(s) from the plotted map A. For this dataset, we identify the 6 cells as the novelty cells. (since torus dataset does not have outliers we are using this for demo purpose.)

-   We pass the identified novelty cell(s) as a parameter to the removeNovelty() along with HVT torus_mapA. The function removes that novelty cell(s) from the dataset and stores them separately. It also returns the data without novelty(s).

-   The plotNovelCells() constructs hierarchical voronoi tessellations and highlights the identified novelty cell(s) in red.

-   The data with novelty is then passed to the trainHVT() to construct another HVT map (torus_mapB). But here, we set the parameters **`n_cells`** = 10, **`depth`** = 2 etc. when constructing the map.

-   The data without novelty is then passed to the trainHVT() to construct another HVT map (torus_mapC). But here, we set the parameters **`n_cells`** = 46, **`depth`** = 2 etc. when constructing the map.

-   Finally, the set of maps - torus_mapA,torus_mapB,torus_mapC are passed to the scoreLayeredHVT() along with the test dataset to score which map and what cell each test record is assigned to.

-   The output of scoreLayeredHVT is a dataset with two columns Layer1.Cell.ID and Layer2.Cell.ID. Layer1.Cell.ID contains cell ids from map A in the form A1,A2,A3.... and Layer2.Cell.ID contains cell ids from map B as B1,B2... depending on the identified novelties and map C as C1,C2,C3.....



# 9. References

1. <a href="https://users.ics.aalto.fi/jhollmen/dippa/node9.html" target="_blank">Topology Preserving Maps</a>

2. <a href="https://ocw.mit.edu/courses/6-450-principles-of-digital-communications-i-fall-2006/resources/book_3/" target="_blank">Vector Quantization</a>

3. <a href="https://en.wikipedia.org/wiki/K-means_clustering" target="_blank">K-means</a>

4. <a href="https://en.wikipedia.org/wiki/Sammon_mapping" target="_blank">Sammon's Projection</a>

5. <a href="https://en.wikipedia.org/wiki/Centroidal_Voronoi_tessellation" target="_blank">Voronoi Tessellations</a>
